= 最初の一歩

最初の一歩は、有名な「Python チュートリアル」から多くのサンプルを拝借してきました。
Konoha プログラミングの原点は、Python にあるといったら変な感じもしますが、
「直感的なわかりやすさ」を体験するには、Python 風なチュートリアルが一番です。

ここでは、数値や文字列、配列など、Konoha の最も基本的なデータ表現を用いながら、
Konoha の機能をひとめぐりしていきましょう。

== 数値

対話モード（インタープリタ）は、式を入力すれば答えがえられるので、
そのまま電卓になります。
数式は直感的で、演算子 +, - *, / の優先順位や式のグルーピングなどは、
数学の常識が期待を裏切らずに通用します。

{{{
>>> 2 + 2
4
>>> 2+2       // これはコメント
4
>>> (50 - 5 * 6) / 4
5
>>> 7 /　3 　　// 整数の割り算は切り下げ
2
}}}

変数への代入は、= 演算子を用います。

{{{
>>> width = 20
20
>>> height = 5 * 9
45
>>> width * height
900
}}}

このとき、Konoha は型推論によって変数の型を静的に決定しています。
この話はやや複雑になるので、後述の「型とプログラミング」を参照してください。

=== 数値の種類

コンピュータがもつハードウェアの演算能力を有効に活用するため、
数値は、整数と浮動小数点数の区別があります。
これらは、数値リテラルとして、小数点以下の数の有無で区別されます。

{{{
>>> typeof(3)
int
>>> typeof(3.0)
float
}}}

Konoha は、64ビット時代になってから設計されたため、
整数(int)は64ビット整数、
浮動少数点数(float)はIEEE 754倍精度フォーマットのみサポートします。 

整数と浮動小数点数を混在して演算したとき、
整数は自動的に浮動小数点数に変換されて演算されます。

{{{
>>> 3 * 3.75 / 1.5
7.5
>>> 7.0 / 2
3.5
}}}

明示的な変換は変換子、つまり、いわゆる型キャスト演算子を用います。

{{{
>>> (float)3
3.0000000000
>>> (int)3.2
3
}}}

Konoha は、すべてのデータ変換操作を変換子で統一的に行えるように
なっています。より詳細は、後述の「トランスフォーマとフォーマッタ」を
参照してください。

最後に、より高度な数値計算には、ライブラリを活用することができます。
次は、math パッケージから、Math クラスを利用した例です。

{{{
>>> using math.Math;
>>> Math.sart(2)
@@
}}}

== 文字列

Konoha は、
数値に加え、文字やテキストを扱う便利な文字列(String)を用意しています。

文字列は、変数などの識別子と区別するため、
ダブルクオート(")やシングルクオート(')で囲みます。

{{{
>>> "naruto"
"naruto"
>>> 'Say "hi"'
"Say \"hi\""
}}}

シングルクオートは、'A'のように1文字のとき、
C言語との互換性のため、その文字コードの数値(int)として扱われることがあります。
これらは、コンパイラ時の型検査で判断しています。

クオート記号や改行など、特別な文字を文字列に含めるときは、エスケープシーケンスを用います。

{{{
>>> "Naruto said \"Hi.\"\n Sakura said \"Hi.\""
Naruto said "Hi."
 Sakura Said "Hi."
}}}

スクリプトでは、テキストは重要な要素となります。
Konoha は、「読みやすく」文字列をプログラミングできるように、
豊富なリテラルを用意しています。

トリプルクオート('''や""")は、改行やクオートをそのまま解釈し、
よりテキストを読みやすく与えることができます。

{{{
>>> s = '''
... Naruto said "Hi."
...  Sakura said "Hi."'''
}}}

文字列リテラルの先頭に@をつけると、
raw 文字列、つまり\nなどのエスケープシーケンスをそのまま文字列に取り込む
ことができます。

{{{
>>> @ "Naruto said \"Hi.\"\n Sakura said \"Hi.\""
"Naruto said \"Hi.\"\n Sakura said \"Hi.\""
}}}

Konoha の最も驚くべき文字リテラルは、行リテラル # でしょう。
# の続きは、コメントではなく、改行まで文字列として解釈されます。

{{{
>>> s = # Naruto said "Hi."
}}}

隣接する文字列リテラルは連結されるため、
query を次のように与えることもできます。

{{{
query = 
   # select name, age
   #   from PERSON_TABEL
   #   where age < 10
}}}

=== 文字列と演算子

文字列は、演算子を用いること自由自在に編集することができます。
もっともよく用いられるのは、+ 演算子による連結でしょう。

{{{
>>> fname = "Naruto"
>>> lname = "Uzumaki"
>>> lame + " " + fname
"Uzumaki Naruto"
}}}

もっとも最近は、フォーマッティング機能を使う方がスマートかも知れません。
こちらはより複雑な文字列の合成のときに便利になります。

{{{
>>> format("%s{0} %s{1}", lname, fname)
"Uzumaki Naruto"
}}}

Konoha では、%sなどの書式をフォーマッタとして自由に定義することができます。
詳しい利用法は、「フォーマッタとトランスフォーマ」をみてください。

文字列は、文字が並んだシーケンス（列）として扱えます。
文字列から、n番目も文字を取り出したいときは、n-1のインデックスを指定します。
(C言語と同様にインデックスは0から始まります。）

{{{
>>> name = "naruto"
>>> |name|      // 文字列の長さ
6
>>> name[1]
"a"
}}}

Konoha は、はじめから多国語化された設計であり、
文字コードに依存せず、文字数単位でインデックスを指定できるため、
「日本語の扱い」で悩むこともありません。

{{{
>>> name = "なると"
>>> |name|      // 文字列の長さ
3
>>> name[1]
"る"
}}}

スライス演算子s[n to m]を用いることで、
n番目からm番目までの部分文字列を取り出すことができます。

{{{
>>> s = "0123456789"
>>> |s|
>>> s[1 to 8]
"12345678"
}}}

最後の1文字を含めたくない場合は、to の代わりに until を用いることもできます。

{{{
>>> s = "0123456789"
>>> s[1 until 8]
"1234567"
}}}

Konoha の文字列は、変更不可能(immutable)です。
C言語プログラマは、最初のうちはちょっと戸惑うかも知れません。

{{{
>>> name = "naruto"
>>> name[0] = "N"
@@@
}}}

新しい文字列として生成し代入し直すことで、ほとんどの場合は副作用なく
期待する結果がえられます。

{{{
>>> name = name[0].toUpper() + name[1 to...]
"Naruto"
}}}

=== 文字操作に関するメソッド

Konoha は、オブジェクト指向プログラミング言語であり、
文字列操作に関する様々なツールをStringクラスのメソッドとして提供しています。

man String を用いれば、
String クラスがサポートしている演算子やメソッドを調べることができます。

{{{
>>> man String
Class
	konoha.String
Operator
	     x + y       x - y   x[m to n]  x[m until n]        x[n]  
	    y in x         |x|  
Method
	String concat(Any? value, ...)
	boolean endsWith(String s)
	boolean endsWith:IgnoreCase(String s)
	boolean equals(String s)
	boolean equals:IgnoreCase(String s)
	String format(Any? value, ...)
	Bytes getBytes(String? enc)
	int getChar(Int? n)
	int indexOf(String s)
	int indexOf:IgnoreCase(String s)
	boolean isAscii()
	int lastIndexOf(String s)
	int lastIndexOf:IgnoreCase(String s)
	String[] match(Regex pattern)
	String new(Bytes buf, String? enc)
	boolean opMatch(Regex re)
	String replace(String s, String newone)
	String[] split(String delim, int isTrim)
	boolean startsWith(String s)
	boolean startsWith:IgnoreCase(String s)
	String substring(Int? offset, Int? length)
	String times(int n)
	String toLower()
	String toUpper()
	String trim()
	Pair<String,String> twofold(String s)
Formatter
	%k %s 
Transformer
	String
		--> Boolean
		--> Int
		--> Float
		--> Bytes

}}}

Konoha プロジェクトでは、可能な限り Java 言語や既存の有名ライブラリと
同じ名前でメソッド名を定義し、プログラマの負担や混乱を軽減しています。

=== 配列とリスト

配列は、もっとも基本的な複合データ構造です。
各要素をカンマで区切った上、四角カッコ[ ]で囲みます。

{{{
>>> a = [0, 1, 2]
[0, 1, 2]
}}}

このとき、要素の型によって配列の型は決定されます。
上の例では、要素がすべてint 型なので、int[] 配列になります。

配列は、その要素の値をインデックスから取り出したり、変更することができます。
インデックスは、文字列と同様に 0 から始まります。

{{{
>>> a[1]
1
>>> a[1] = a[1] + 10
>>> a
[0, 11, 2]
}}}

Konoha の配列は、可変長配列(growing array)なため、
リストとしても広く活用することできます。

add()メソッドや << 演算子を用いることで、
配列の最後に要素を追加することができます。

{{{
>>> a
[0, 11, 2]
>>> a.add(3)
[0, 11, 2, 3]
>>> a << 0 << 1
[0, 11, 2, 3, 0, 1]
}}}


[[PageBreak]]
= 変数と型

Konoha のスクリプティング言語としての特徴は、「静的に型付け」されている点です。

これは、変数はコンパイルされるとき、その変数の型が決まっていることを意味します。
今、新しく変数 s に文字列を代入したいと思えば、次のとおり、変数を宣言します。

{{{
String s = "naruto";
}}}

Java プログラマなら、当たり前ですネ。

== 型推論

変数宣言は、「こんなのスクリプティング言語じゃない！！」というお怒りの声多数、
声にもならない失望のため息はそれ以上、とにかくこれは評判がよろしくありません。

そこで、Konoha では型推論のアイディアを採用し、変数宣言を明示的にしなくても、
変数の型を決定されるようにしました。

{{{
>>> s = "naruto";
>>> s
"naruto"
}}}

Konoha は、変数 s はあくまでもString型として静的に型付けされているため、
String 型以外は代入することはできません。

{{{
>>> s = 1;
 - [(shell):4]:(type error) not String
}}}



== null とデフォルト値

Konoha の特徴は、Null 




