= クラスルーム


=== アドレス演算子

アドレス演算子は、変数 x の値が格納されているアドレスを返す。ただし、Konoha はポインタ演算をサポートしていないため、この機能は完全にクラスルーム目的で導入されています。

{{{
&x                        // x のアドレス
}}}

Konohaは、ポインタ型をサポートしていないため、アドレス演算子の演算結果は、int 型です。%p|フォーマッタを使えば、アドレスとして表示されます。

{{{
>>> s = "hello, world"
>>> %p(&s)
00000000
}}}



== 変数の型宣言}
¥index{かたせんげん@型宣言}

Konoha の変数は、静的に型付けされています。プログラマは、新しい変数を使うとき、型宣言が必要となります。C/C++やJavaと同様、次の構文で変数$name$の型$T$を宣言することができます。

¥begin{quote}
$T$  | $name$;
¥end{quote}

また、変数宣言では、必要に応じて、代入演算子によって変数の初期値を与えることもできます。また同じ型であれば、複数の変数をひとつのステートメントで宣言できます。

{{{
String s;                          // 初期値なし
String t = "hello,world";          // 初期値あり
String u, v = "ABC";               // 同じ型の複数の変数宣言
}}}

=== クラスと型}

Konoha は、オブジェクト指向プログラミング言語であるため、全ての宣言されたクラスC}を「C}」型として利用することができます。また、クラス名C}に修飾子を付けることで、その型のnull}値の扱いを変更したり、配列型やイテレータ型の短縮名も利用することができます。

{{{
C                      C 型 
C?                     @Nullable C 
C!                     @NonNull C 
C[]                    C の配列型
C..                    C のイテレータ型
}}}

Konoha の大きな特徴は、型に@Nullable|または@NonNull|を修飾できることです。これらは、名前が示すとおり、変数の値としてnull}値を認めるかどうかであるか、を制約を付加したものです。Java との大きな違いは、何も修飾しなければ、原則として NonNull型となる点です。この場合、変数宣言の初期値は、null} ではなく、そのクラスのデフォルト値となります。

{{{
>>> String s;                    // 初期値のデフォルト値
>>> s
""
>>> s = null                     // Null例外が発生
 ** Null!! 
}}}

注意：各クラスC}のデフォルト値は、組み込み関数 default(C)|を用いて得ることができます。また、デフォルト値の中には Nullオブジェクトパターンにしたがって、null} 値のように振る舞う値もあります。

逆に、C¥#風に?|を型名に付けるか、@Nullable修飾子を用いれば、null} を保持可能な変数となります。この場合の初期値は、null} です。

{{{
>>> String? t;                   // 初期値はnull
>>> t
null
}}}

=== var} 文*}

var} 文は、JavaScript など一部のスクリプティング言語で採用されている変数宣言のための特別なステートメントです。Konoha では、静的に型付けして型宣言を行うため、var} 文では初期値から型推論を行い、静的な型付けを行っています。

{{{
var i;                             // Any 型（型推論なし)
var s = "hello,world";             // s は、String 型
var x = Math.cos(0.75);            // x は、Float 型
}}}

注意：var} 文は省略可能です。始めての使用する変数への代入は、型推論による変数宣言とみなされます。詳細は、「第¥ref{dynamic} 章 ダイナミック・スタイル」で解説する。

== foreach文}

%The foreach statement iterates over each element in an Iterator object. 

foreach} は、イテレータパターンを扱う専用のループ構造です。foreach文は、次の２種類のバリエーションが存在するが、どちらもイテレータ評価式$itr$によるイテレータ内の各オブジェクトをイテレーション変数$var$に代入し、イテレータ内のオブジェクトがなくなるまで、ステートメント$stmt$の実行を繰り返す。

¥begin{quote}
foreach(| $var$  in | $itr$ ) | $stmt$; ¥¥
foreach(| $var$  from | $itr$ ) | $stmt$; ¥¥
¥end{quote}

foreach文は、多くの場合、for} 文を用いるよりも可読性が高くなり、また（専用命令のおかげで）高速な処理が期待されます。

{{{
>>> a = [0, 1, 2]
>>> for(i = 0; i < |a|; i++) {   // for版(古風)
...   n = a[i];
...   print n;
... }
n=0
n=1
n=2
>>> foreach(n from a) {          // foreach版
...   print n;
... }
n=0
n=1
n=2
}}}

=== イテレータの評価式}

foreach} 文の in}/from} 節は、任意の式からイテレータをえるため、イテレータ評価式と呼ばれています。Konoha では、イテレータをえる方法は、マッピングによる方法とイテレータ演算子を用いる方法の2種類が存在し、foreach文ではイテレーション要素の型が与えられているかどうかで、自動的に使い分けられます。

¥subsubsection{型が与えられている場合}

イテレーション要素の型が決まっている場合、つまりイテレーション変数の型が明示的に与えられている場合、foreach文は、マッピングによってイテレータを評価する。つまり、次の場合、イテレーション変数 {¥tt line}はString}型であるため、イテレーション評価式は、(String..)(file)|で評価されます。

{{{
file = new InputStream("file.txt");
foreach(String line from file) {
   print line;
}
}}}

¥subsubsection{型が与えられている場合}

イテレーション要素の型が決まっていない場合、foreach文は、イテレーション演算子でイテレータを取り出す。次の場合、(file)..|で評価されます。同時に、このとき得られたイテレーションの型(int..|)からイテレーション変数 tt} の型は、int|と型推論されます。

{{{
file = new InputStream("file.txt");
foreach(ch from file) {
   print ch;
}
}}}

=== フィルタと変換}

foreach} 文の in}/from} は、ほぼ同じ動作をする。違いは、イテレータから得られるオブジェクトとイテレーション変数の型が異なった場合、 フィルタ処理にするか、変換を試みるかの違いです。

¥subsubsection{in}節：型検査によるフィルタ}

foreach} 文と in} は、多くのプログラミング言語で組み合わせられているペアであり、イテレータ内部のものを加工せずに取り出す意味論に近いため、型検査によるフィルタ処理を行っています。

{{{
>>> a = ["naruto", 9, "gahra", 1];
>>> foreach(String s in a) {
...   print a;
... }
a="naruto"
a="gahra"
}}}

¥subsubsection{from}節：マッピングによる変換}

from}節は、本来、次節で述べる通り、 クエリー言語に由来しており、特別に変換の意味と結びつけられたものではないが、Konoha のforeach 文では変換しながらのイテレーション処理と定義されています。変換できなかったオブジェクトは、無視されます。

{{{
>>> a = ["naruto", 9, "gahra", 1];
>>> foreach(String s in a) {
...   print a;
... }
a="naruto"
a="9"                          // String へ変換
a="gahra"
a="1"                          // String へ変換
}}}

=== where}節*}

Konoha における foreach} 文は、SQLやXMLQueryなど、クエリー言語をモデルにしています。そのため、クエリー言語のwhere} 節に相当する検索条件を書くことができます。

¥begin{quote}
foreach(| $var$  from | $itr$  where | $expr$ ) | $stmt$; ¥¥
¥end{quote}

現在は、where}節による条件検索は、Konoha 言語処理系の上で実行されているため、それほど高速ではない。将来は、foreach文の処理を一部ダイレクトにクエリー展開し、データソースアクセスとスクリプティングをシームレスに統合する計画があります。

{{{
foreach(Person p 
         from 'db:PERSON_TBL' 
         where p.age > 20 and p.age <= 60) {
   print p.name, p.salary;
}
}}}

== ステートメント・アノテーション*}

Konoha は、全てのステートメントに対し、アノテーションを付けることで、ステートメントの意味や振る舞いを拡張することができます。
アノテーションは、@|マークで始まる識別子であり、ひとつのステートメントに対し、複数のアノテーションを同時に与えることもできます。ただし、アノテーションとステートメントの間にセミコロン(;)を入れてはならない。

{{{
@Date print n;
@Const @Nullable String s;
}}}

各ステートメントによって、対応しているアノテーションの種類は異なります。未定義のアノテーションを利用しても、現在のところ、エラーも警告も発生しない。将来は、ユーザが自由に拡張したアノテーションを使うフレームワークを用意する予定です。
さて、もうひとつ Konoha には各クラスごとにデフォルト値が設定されています。
組み込み関数デフォルト default(C) を使えば、クラスCのデフォルト値を
得られます。

{{{
>>> default(String)
""

}}}

ここで、(*)x と同じ原理で、default(*) を略すと、
要求された型のデフォルト値を呼び出すショートカットになります。

{{{
>>> String s = *;   // default(*) のこと
>>> s
""

}}}



{{{
class Person {

}}}

{{{ comment
 * '''フィールド変数'''は、SmallTalk ではインスタンス変数、C++ではメンバ変数、Java ではフィールドとそろぞれ異なる呼称をもつが、オブジェクトの内部状態を表す変数です。Java ではフィールド変数と呼ばないのが正しいが、Konoha では変数の種類をその位置によって区別する統一呼称を用いているので、「フィールド変数」と呼んでいます。
 * '''メソッド'''は、SmallTalkではメッセージ、C++ではメンバ関数とも呼ばれるが、オブジェクトの内部状態を操作する手続きです。メソッドは、関数のフォームをとり、パラメータ（メソッドにおける引数のこと）を受けて処理を行い、その結果を戻り値として返す。Konoha では、オブジェクトへの操作が明確なときはメソッド/パラメータ、そうでないときは手続き型言語風に関数/引数と呼び分けています。どちらも同じです。
 * '''コンストラクタ'''は、新しくオブジェクトを生成するときに、new|演算子を用いて呼び出される特別なメソッドです。なお、Konoha は、ガベージコレクションの機構を備えているため、明示的なオブジェクト破壊を行う必要なない。
}}}


さて、次はKonoha におけるクラス定義の例です。フィールド変数、コンストラクタ、メソッドの定義をもっています。フィールド変数は、class} ブロックの一番先頭で宣言することが（よみやすいため）一般的であるが、定義する順番は自由に変えても構いません。

{{{
class Person {
   String _name;                  // フィールド変数
   int age;
                                  // コンストラクタ
   Person(String name, int age) {
      _name = name;
      _age = age;
   }
   String getName () {           // メソッド
      return _name; 
   }
}
}}}

Konoha は、スクリプティング言語の柔軟さを提供するため、メソッドやコンストラクタを既存のクラスに追加するを認めています。しかし、フィールド変数のみは、class}ブロックであらかじめ定義しなければならない。

=== クラスの種類

Konohaは、いくつかの特性の異なったクラスを分類しています。これらは、class 文} の前に、アノテーションを与えることで宣言することができます。

{{{
アノテーション         説明
@Private              名前空間からみることはできない。
@Final                これ以上、継承することはできない
@Singleton            Singleton 関数
@Interface            インターフェースとして利用することが可能
@Release              デバッグの完了したクラス
}}}

=== Glue}クラス}

オペレータとは、1つ以上の式を結びつけて評価する機構です。+|や=|などの演算子と呼び直した方がわかりやすいだろう。近代的なオブジェクト指向プログラミング言語は、ほとんどのオペレータはメソッドの一部として実現し、それをシンタックスシュガー（糖衣構文）として使いやすく提供しています。本章では、Konoha が提供するオペレータの全体像を知るため、一般的な紹介を行う。オペレータは、ある特定のクラスや機能と密接に関係したものも多いが、それらは後に続く章において個々に詳説されます。

== 代入演算子}

代入演算子は、変数 x に 右辺式 y を評価した結果を代入(格納)する演算子です。

{{{
x = y                       // y の評価値をxに代入する
}}}

左辺値x|となりうる値は、変数、プロパティ変数、フィールド、配列や辞書に限られます。定数は、未定義の場合に限り、定数値を定義するために代入することができます。次は、代入可能な右辺値の例です。

{{{
name = "naruto"
$name = "naruto"
p.name = "naruto"
p[0] = "naruto"   
p["name"] = "naruto"
P = "naruto"                // 定数は、1回のみ代入可能
}}}

=== 代入式の代入*}

Konohaでは、代入演算自体も式として扱うことができます。つまり、代入 x = y| の評価値は、(代入後の) x となります。したがって、次のように、同じ値を複数の変数へ代入することも可能となります。

{{{
>>> y = 2
>>> x = y = 1               // x には、(y = 1) の値が代入
>>> x
1
>>> y
1
}}}

=== 多値セレクタ**}

データ構造から部分的な値を切り出すことは多い。これらのプログラムを簡単に書くため、多値代入を値のセレクタとして利用する拡張計画があります。

{{{
>>> s = ["naruto", "sakura"]
>>> a, b = s;
>>> a                      // s[0] と同じ (s.opFirst())
"naruto"
>>> b                      // s[1] と同じ (s.opSecond())
"sakura"
}}}

== コール演算子}

コール演算子()|は、メソッド/関数 f|、コンストラクタnew C|、もしくはフォーマッタ%f|に続いて用いられ、メソッド/関数を呼び出すときに用います。括弧()|の中には、0個以上のパラメータ/引数を,|で区切って与えることができます。コール演算子の評価値は、メソッド/関数の戻り値となります。(ただし、メソッド/関数の戻り値void 型の場合は、評価値はない。)

{{{
f()                        // 関数 f()のコール
o.f()                      // o のメソッドf()をコール
new C()                    // クラスCのコンストラクタ
%f(o)                      // o のフォーマッティング
}}}

コール演算子で与えられるパラメータは、メソッド/関数ごとに個別に定義されています。定義と異なるパラメータでコールしようとしたときは、型エラーとなります。

{{{
>>> fibo(10)
55
>>> Math.abs(-1)
1.000000
}}}

=== コール演算子の省略}

コール演算子は、パラメータの数が１個であり、かつそれが文字リテラルである場合のみ、括弧()|自体を省略することもできます。次は、c.query("""...""")|と同じであるが、省略した方がすっきりとする。

{{{
>>> c.query """
select name, salary from PERSON_TBL
  where age > 45 and age < 65;
"""
}}}

== アドレス演算子}

アドレス演算子は、変数 x の値が格納されているアドレスを返す。ただし、Konoha はポインタ演算をサポートしていないため、この機能は完全にクラスルーム目的で導入されています。

{{{
&x                        // x のアドレス
}}}

Konohaは、ポインタ型をサポートしていないため、アドレス演算子の演算結果は、int 型です。%p|フォーマッタを使えば、アドレスとして表示されます。

{{{
>>> s = "hello, world"
>>> %p(&s)
00000000
}}}

== 比較演算子}

%The comparators are defined for all objects. If two of objects are not comparable it will throw an exception. 

比較演算子は、二つの値 x, y を比較するとき用いられ、評価結果は、論理値のtrue} か false} です。

{{{
x == y                    // 等しいか？
x != y                    // 等しくないか？
x < y                     // より小さいか？
x <= y                    // 以下か？
x > y                     // より大きいか？
x >= y                    // 以上か？
}}}

Konohaでは、全ての型において、x, y の比較が可能です。これは常に意味のある比較となることを保証しない。特に、x と y の型が異なる場合、かつ概念的にも比較が意味をなさない場合は、オブジェクトID（アドレス値）の比較が返されます。どちらにしても、比較演算の評価値は、一意となります。

{{{
>>> 1 < 2.0               // 整数と浮動小数点は比較可能
true
>>> 1 == "1"              // 比較不可能な型
false
}}}

=== マッチング演算子}

マッチング演算子は、Perl に由来し、主に正規表現と文字列のマッチングに用いられます。

{{{
x =~ y                    // xは、パターンyと等しいか？
}}}

マッチング演算子は、==|と異なり、対称ではない。パターンは、必ず右辺に与える必要があります。

{{{
>>> s = "hello, world"
>>> s =~ /w.*d/
true
}}}

=== {¥tt instanceof} 演算子*}

{¥tt instanceof} 演算子は、Java に由来し、x がクラスCのインスタンスであるか判定する。Konohaは、純オブジェクト指向言語であり、全ての値は何らかのクラスのインスタンスです。そのため、任意のxに対して、{¥tt instanceof} を用いることができます。

{{{
x instaceof T            // x は、Tのインスタンスか？
}}}

整数 {¥tt 1} は、Float}のインスタンスではないが、Number}のインスタンスです。{¥tt instanceof} 演算子は、次のようにテストできます。

{{{
>>> 1 instanceof Float
false
>>> 1 instanceof Number
true
}}}

また、null はどのクラスのインスタンスでないため、常に {¥tt instanceof} 演算子の結果は、false} となります。ただし、Any}型のみ true}となります。

{{{
>>> null instanceof Object
false
>>> null instanceof Any
true
}}}

== 論理演算子}

論理演算子は、論理式（評価結果が論理値となる式）を論理的に連結し、より複雑な論理式を作る演算子です。

{{{
x && y                    // x かつ y がtrueのとき
x || y                    // x または y がtrueのとき
!(y)                      // x がfalse のとき 

x and y                   // x && y と同じ
x or y                    // x || y と同じ
not y                     // !(x) と同じ
}}}

Konoha の論理演算子は、C/C++, Java互換の記法と、Python 由来の記法の両方をサポートしています。どちらを使っても構わないが、C/C++, Java との互換性を重んじるなら、&&|, ¥verb#||#, !|を用いる方が無難です。

{{{
>>> a = 1
>>> b = 2
>>> a == 1 && b == 2
true
>>> a == b || a < b
true
>>> !(a == b)
true
}}}

論理演算を混在したとき、!|, &&|, ¥verb#||# の順に演算されます。ただし、()|で囲まれた式は優先的に評価されます。論理式を混在させるときは、読みやすさのため、()|で明示的に優先する論理式を与えるのがよい。

{{{
>>> a = 1
>>> b = 3
>>> !(a == 1) && b == 3 || a < b
true
>>> !(a == 1) || b == 3 && a < b
false
>>> (!(a == 1) || b == 3) && a < b
true
}}}

=== 条件演算子}

条件演算子は、条件によって評価する式を切り替える演算子です。Konoha は、次の2種類の条件演算子をサポートしています。

{{{
x ? y : z                 // xがtrueのときy、そうでなければz
x ?? y                    // xがnullのときy
}}}

演算子 x ? y : z| は、3項演算子とも呼ばれ、条件式x|の評価結果によって、式y| か 式z|が評価されます。3項演算子は、読みにくくなるので、各式の周りは()|で囲んだ方がよい。

{{{
>>> a = 1; b = -1;
>>> a = (a < b) ? (a) : (b);
>>> a
-1
}}}

演算子 x ?? y| は、C¥#で導入された null 検査用の条件演算子です。意味は、(x != null) ? x : y| と同じです。ただし、null 検査を連続するときは、こちらの方がはるかに読みやすい。

{{{
>>> name = student["name"] ?? ninja["name"] ?? "unknown";
}}}

== 算術演算子}

% The arithmetic operators (+ - * / %) are defined for all numeric types, such as Int and Float.

算術演算子は、2つの数値 x, y に対し、四則演算を行うときに用いられます。また、文字列など一部のクラスには算術演算子は、連結や分離などの意味で定義されていることもあります。

{{{
x + y                     // 加算
x - y                     // 減算
x * y                     // 乗算
x / y                     // 除算
x % y                     // 余り（モジュロ）
x mod y                   // x % y と同じ
}}}

モジュロ演算子 %| は、C/C++, Javaで広く採用されているが、Konoha ではフォーマッタ名と区別しにくいので、{¥tt mod} を使うか、演算子の前後に明示的に空白を入れることが推奨されています。

算術演算子は、四則演算の優先順位にしたがって評価されます。つまり、乗算(*|)と除算(/|)の優先度は、乗算(+|)と除算(-|)より高く、同じ優先度の場合は左から順番に評価されます。評価順序を変更する場合は、先に評価したい式を括弧()|で囲めばよい。

{{{
>>> 1 + 2 * 3
7
>>> 1 + 2 - 3 * 4 / 2
-3
>>> (1 + 2) * 3
9
}}}

=== 算術代入}

算術代入は、代入演算子と算術演算子を組み合わせたシンタックスシュガーです。

{{{
x += y                    // x = x + y
x -= y                    // x = x - y
x *= y                    // x = x * y
x /= y                    // x = x / y
}}}

算術代入は、代入可能な右辺値であれば、全て適用することができます。

{{{
>>> a = [0, 1]
>>> a[0] += 1              // a[0] = a[0] + 1 と同じ
>>> a
[1, 1]
}}}

ただし、a[n++] += 1|のような副作用が生じる場合は、期待通りの算術代入にはならない。

=== インクリメントとデクリメント}

Konoha は、"Everything is an Object" の世界で、Int オブジェクトは Immutable なので、本来の意味でインクリメントとデクリメントをサポートできない。しかし、あまりに利用者からの要望が多いため、シンタックスシュガーで対応しています。現在のところ、前置、後置演算の区別はない。

{{{
x++                       // x = x.opNext()
++x                       // x = x.opNext()
x--                       // x = x.opPrev()
--x                       // x = x.opPrev()
}}}

Konohaでは、インクリメント/デクリメント演算子は、ステートメントとして利用することを推奨しています。式として利用した場合、その評価順序は、将来にわたって保証されない。

{{{
>>> for(i = 0; i < 3; i++) print i;
i=0
i=1
i=2
}}}

== ビット演算子}

Konohaは、Cスタイルのビット演算子をInt型に対してサポートしています。スクリプティング言語において、これらの演算子を多用することは稀であり、これらは教育用を主目的¥footnote{バーチャルマシンにおいて専用命令としてチューニングされないと意味です。}として用意されています。

{{{
~x                        // ビット反転
x & y                     // 論理積
x | y                     // 論理和
x ^ y                     // 排他論理和(XOR)
x << y                    // 左シフト
x >> y                    // 右シフト
}}}

フォーマッタ%bits| は、ビット演算子の結果を表示するとき利用できます。

{{{
>>> %bits(~0)
11111111 11111111 11111111 11111111
>>> %bits(1 << 2)
00000000 00000000 00000000 00000100
}}}

== シーケンス演算子}

%Konoha supports several convenient operators for sequence/set objects, such as Array, byte[], HashMap, HashSet, DictMap, and DictSet. 

Konoha は、シーケンス（順序を保って並んだ集合）に対して、その操作に関する一連の演算子を提供し、それらを総称してシーケンス演算子と呼ぶ。代表的なシーケンスの例は、Array}, {¥tt byte[]}, String}などがあります。

{{{
|s|                       // シーケンス s のサイズ
s[n]                      // n番目の値 
s[n] = x                  // n番目に値xをセットする
s[] = x                   // 全部に値xをセットする
x in? s                   // s に xが含まれているか？
s << x                    // s への x の追加
}}}

シーケンス演算子では、シーケンスの要素の種類によらず、シーケンスのインデックスn|に対して、常に $0 ¥le n < ¥verb#|s|#$が保証されます。(ただし、DictMap}やHashMap}のように、インデックスの代わりにキーを用いる場合はこの限りでない。)

{{{
>>> a = [0, 1, 2, 3]
>>> |a|
4
>>> a[1]
1
}}}

=== インデックスの範囲}

インデックスn|が最大値¥verb#|s|#を超えた場合は、OutOfIndex!!|例外となります。古いKonoha では、Python と同様に、最後尾から数えてインデックスし直していたが、配列の境界チェックの最適化を考慮に入れて、負のインデックスは見送られた。

{{{
>>> a[-1]
 ** OutOfIndex!!: 
}}}

=== シーケンスへの追加}

演算子 <<|は、特別なシーケンス演算子であり、複数の要素を連続して追加することもできます。

{{{
>>> a = [1]
>>> a << 2 << 3 << 5 << 7;
>>> a
[1, 2, 3, 5, 7]
}}}

== スライシング演算子}

スライシング演算子は、シーケンスから部分シーケンスを取り出す演算子です。Python のスライシング演算子とよく似ているが、Konoha では部分シーケンスの定義の仕方が3種類用意されています。

{{{
s[x..y]                   // x番目からy番目(含む)まで
s[x..<y]                  // x番目からy番目まで
                          //  s[x..(y-1)] と同じ 
s[x..+y]                  // x番目からy個の部分
                          //  s[x..(x+y)] と同じ 
}}}

文字列は、シーケンスの一種であり、スライシングで部分文字列を得ることができます。

{{{
>>> s = "konoha"
>>> s[2..3]
"no"
>>> s[2..<3]
"n"
>>> s[2..+3]
"noh"
}}}


よく似た演算子が3種類存在する理由は、これらはよく混同されて間違えるためです。逆に、３種類、範囲除外(..<|)やオフセット(..+|)をイメージしやすい演算子を導入することで、どれかを正しく使いやすくなります。また、スライシングs[x..y]|の範囲 x y|は、それぞれ省略可能です。省略したときは、それぞれ x = 0|, ¥verb#y = |s| - 1#が初期値として採用されます。

{{{
>>> s = "konoha"
>>> s[2..]
"noha"
>>> s[..4]
"kono"
>>> s[..]                  // シーケンスのコピー
"konoha"
}}}

== キャスト演算子}

Konoha は、オブジェクト間のデータ変換や意味変換を強力にサポートするマッピング機能を独自に導入しています。これらは、C/C++, Java 言語でおなじみのキャスト演算子に統合され、利用可能です。

{{{
(T)x                      // xの型Tへの変換（キャスト）
x to? T                   // xは型Tへ変換可能か？
}}}

マップキャスト演算子(T)x|は、ソース型typeof(x)|とターゲット型T|の関係で動作が異なります。サブタイプの関係が成り立つ場合は、通常どおり、アップキャスト、もしくはダウンキャストされます。それ以外の場合は、マッパーが検索され、それが評価されます。

{{{
>>> Object o = "123";
>>> s = (String)o;                  // ダウンキャスト
>>> n = (int)o;                     // マップキャスト
>>> n
123
}}}

また、マッピングが定義されていない場合、つまりキャストができない場合は、ClassCast!!|例外となります。

{{{
>>> (int)true
 ** ClassCast!!: Boolean ==> Int
}}}

これらの演算子は、マッピング機能を応用して実現されています。詳しくは、「第¥ref{mapping}章 マッピング機能とデータ変換」で述べます。

== イテレータ演算子*}

イテレータ演算子は、オブジェクトから(標準)イテレータを得るときに用います。foreach} 文において、イテレータを生成するときに用いる（内部）演算子であるが、プログラマが用いても構いません。

{{{
x..                       // x の(標準)イテレータ
}}}

次の例では、整数配列Int[]|からイテレータ(Int..|)を得ています。

{{{
>>> a = [0, 1, 2]
>>> typeof(a..)
>>> a..
1
2
3
}}}

イテレータ型や標準イテレータの定義は、「第¥ref{iteration}章 イテレーション」で詳しく述べます。

== セマンティック演算子**}

Konoha は、オブジェクト指向モデルの軽量オントロジ拡張を行い、クラスやオブジェクト間の意味的な関係を比較することができます。

{{{
x isa? y                  // x は、y か？ IS-A 関係 
x === y                   // x と y は意味的に等しいか？
}}}

Konohaは、文字列や数値に意味タグを付加することができます。次は、華氏(32.0F)と摂氏(0.0C)の比較です。

{{{
>>> Float:F temp = 32.0F;
>>> temp == 0.0C;
false
>>> temp === 0.0C;
true
}}}

これらの演算子は、マッピング機能を応用して実現されています。詳しくは、「第¥ref{chapter:semantikcogramming}章 セマンティックプログラミング」で述べます。

[[include(KbookIndex)]]
[[include(KbookFooter)]]

