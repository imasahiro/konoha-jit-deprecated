¥chapter{例外処理}例外は、動的な非局所ジャンプの一種です。== 例外クラス Exception}Exception}は、例外の種類、状態を表現するクラスです。クラス Exception} は、Konoha において例外を実現する唯一のクラスです。例外の種類は、例外クラス内部の表現として分類され、どの例外もException} クラスのインスタンスとなります。{{{>>> e = new Security!!();>>> e.classException>>> e = new IO!!();>>> e.classException}}}== throw} 文} ¥index{throw@throw文}Konohaは、プログラム実行中に何らかの異常を検出したとき、例外をスローする。例えば、0除算が発生した場合、その異常状態はArithmetic!!|例外がスローされたことで知ることができます。{{{>>> a = 0;>>> 1 / a;** Arithmetic!!: Divide by Zero}}}同様に、プログラマ自身も、専用のステートメント throw} を使うことによって、例外をスローすることができます。最も標準的な例外のスローは、新しく例外クラスを作成し、それをthrow} 文に与える方法です。{{{>>> throw new Security!!("Something wrong");** Security!!: Something wrong}}}Konoha のthrow文では、文字列（エラーメッセージ）をそのまま投げることができます。文字列の先頭が例外名のタグであれば、例外の種類が適切に判別され、そうでなければ単純にException!!|になります。{{{>>> throw "Security!!: Something wrong";** Security!!: Something wrong}}}%例外をスローすると、プログラムの正常化を行うため、catch文によって捕捉されるまで大域的にジャンプする。ただし、異常の状況が軽度な場合は、エラーの記録にとどめておけば十分な場合も多く、throw文の代わりに warn文を入れ替えることでログ出力に変更できます。%%{{{%warn "Security!!: Something wrong";%}}}%== try-catch文} ¥index{try@try文} ¥index{catch@catch節}try-cacth文は、try}ブロック内で発生した例外を捕捉（キャッチ）し、プログラムの正常化を行うための制御構造です。{{{try {   // ブロックでスローされた例外に対する}catch(IO!! e) {   // プログラムの正常化}}}}catch} 節は、複数種類の例外をそれぞれ処理することができます。例外はソースコードの順に先頭からマッチング処理を行われ、最初にマッチングした catch}節が処理されます。マッチングは、e instanceof E!!|による半順序マッチングであり、複数のcatch}節の条件にマッチする可能性があるが、最初のひとつ以外はcatch}節は無視されます。{{{try {   // ブロックでスローされた例外に対する}catch(Security!! e) {   // プログラムの正常化}catch(SQL!! e) {   // プログラムの正常化}catch(IO!! e) {   // プログラムの正常化}}}}また、どのcatch}節の例外処理にもマッチしなかった場合は、例外は捕捉されることなく、そのまま継続してスローされ続ける。== finally}節}　¥index{finally@finally節}%== Security!!}例外}