¥chapter{Konohaの特徴}Konoha の特徴は、ひと言で言えば、「静的に型付けされたスクリプティング言語」です。しかし、スクリプティング言語は、別名「ダイナミック言語」と呼ばれるとおり、動的に型付けされています。そのため、Konoha は、どこかしら保守的でもあり、逆に新しさもあるスクリプティング言語となっています。本章では、Konoha の特徴を簡単なソースコードとともに紹介したいと思う。== おなじみの言語文法}Konoha の文法は、C/C++ や Java と高い互換性をもっています。これは、はじめてプログラミングを学ぶ者にとって、C/C++, Java などのメインストリーム言語の良き導入になるだけでなく、経験あるプログラマにとって特別な努力を費やすことなく、Konoha プログラミングがはじめられることを意味する。次は、おなじみfibonacci 数列を再帰で求める関数です。C/C++, Java でも、もちろん Konoha でも全く同じように実行することができます。{{{int fibo(int n) {  if(n < 3) return 1;  return fibo(n-1)+fibo(n-2);}}}}一方、これが、Perl や Python, Ruby, Lua など、他のスクリプティング言語であったら、やはり独特な文法のため、いきなり簡単な fibonacci 関数も書くことは難しい。次は、「Java風の文法をもった」といわれる、JavaScript によるfibonacci 関数の例であるが、はやり無視できない大きな違いがいくつもあります。¥begin{source}function fibo(n) {       // JavaScript の場合  if(n < 3) return 1;  return fibo(n-1)+fibo(n-2);}¥end{source}Konohaが、従来のJava風スクリプティング言語と比べて、高い文法互換性をもっている理由は、Javaと同じく静的に型付けされている点に大きい。これによって、オブジェクト指向プログラミングにおいても、よりJavaに近いモデリング手法でクラスを設計することができます。次は、Counter} クラスの定義の例です。クラス宣言に始まり、コンストラクタからフィールドまで、通常のプログラミングにおいて、まず問題にならないレベルの互換性があります。{{{class Counter {  int cnt;  Counter(int n) { cnt = n; }  void count() { cnt++; }  void reset() { cnt = 0; }}}}}ただし、Konoha は、独立したプログラミング言語です。文法の互換性は、あくまでもC/C++やJavaプログラマへの混乱を最小限にとどめるために導入されています。もちろん、スクリプティング言語として、簡略化されている部分もあるし、独自に拡張されている文法もあります。== 対話的な動作: Looks like Java, Runs like Python}Konohaプロジェクトのキックオフ当時の目標は、"Looks like Java, Runs like Python"、つまり「Javaのように書けてPythonのように実行できる」であった。現在、Konohaは、Python のみならず、Ruby や JavaScriptなど、様々な言語の「よい設計」を取り込んでいるが、Konohaのスクリプティング言語としてのお師匠といえば、Python なのです。Python へのオマージュが最もよくあらわれている部分が、対話モードです。{¥tt konoha }コマンドを実行すると、{¥tt python}コマンドと同様に対話モードが起動する。¥begin{small}{{{$ konohaKonoha 0.3.10 (Rufy) GPL2 (#544, May  2 2009, 09:37:22)[GCC 4.0.1 (Apple Inc. build 5490)] on macosx_32 (32, UTF-8)Options: iconv sqlite3 thread regex used_memory:412 kb>>> }}}¥end{small}>>>| は、コマンドプロンプトです。複数行にわたる場合は、2行目以降は、...| となります。ここにプログラム（式もしくはステートメント）を入力すると、次の行にはその実行結果が得られる。{{{>>> print "hello, world"hello, world}}}Konoha の対話モードは、Lisp の対話的プログラミングほど、それ自体で成り立つプログラミング環境ではない。しかし、Konohaの機能、動作を試したいとき、十分に役立つ機能です。もちろん、先ほどのfibonacci 関数も、対話モードで定義し、その場で実行することもできます。{{{>>> int fibo(int n) {...    if(n < 3) return 1;...    return fibo(n-1)+fibo(n-2);... }>>> fibo(10)55}}}== 型推論}Konohaの特徴は、静的な型付けです。これは、ごく一般的に言えば、変数の型宣言をプログラマに強制することを意味する。ダイナミック言語に親しんできたプログラマには、これは何かしら面倒な話に聞こえてしまうだろう。{{{int n = 1;                         // 変数宣言}}}念のため補足しておけば、静的な型付けは、プログラミングモジュールの仕様を明示的に定義することであり、大規模なソフトウェア開発やグループ開発において、ケアレスミスや誤解によるソフトウェアクラッシュを防ぐ重要な機能です。Konoha がスクリプティング言語であっても、静的に型付けされているのは悪い話ではない。それでも、慣習とは恐ろしいもので、次のようにいきなり変数を使いたくなることもあります。{{{n = 1;                             // 変数宣言なし}}}Konohaは、非常に限定的であるが、実用的に十分な型推論(type inferencing)の機構を備え、明示的に変数宣言をしなくても、その変数の型を推論する機能を備えています。これは、変数宣言なしであっても、変数の初期化の値からその変数の型を推論する機能です。{{{>>> a = [1,2,3]                    // 推論による型宣言>>> n = a[1]>>> typeof(a)                      // 静的な型付けを調べるInt[]>>> typeof(n)Int}}}Konohaの型推論は、プログラミングのしやすさと型宣言による厳密な仕様定義の間で、バランスをとりながら設計されています。また、型を推論できなかった場合、Any}型による「動的な型付けのオプション」も用意されています。{{{>>> s = null;                      // 型推論できない>>> typeof(s)Any}}}Any} 型やダイナミック言語の特性を活かしたプログラミングは、「第 ¥ref{dynamic_style} ダイナミック・スタイル」でより詳しく解説する。== 最速水準の実行性能}スクリプティング言語は、元来、プログラムの実行速度より、プログラムの開発速度へ価値をおいた言語設計であった。そのため、実行性能を単純に比較すると、C/C++やJavaの足下にも及ばない。しかし、今日、より複雑なアプリケーション開発にもスクリプティング言語が利用されるようになるにつれ、スクリプティング言語エンジンの性能向上は大きな関心事になっています。Konoha は、バイトコード型バーチャルマシンで実装されたスクリプティング言語エンジンをもっています。スクリプトは、バイトコードにコンパイルされ、そしてバーチャルマシン上で実行される。次は、コンパイル済みのバイトコード(fibo()|関数)をフォーマッタ機能でダンプした様子です。¥begin{small}{{{>>> %dump(Script.fibo)int main.Script.fibo(int n) [4:0x2038e0] SETESP(30) sfp[2] [4:0x2038e8] iLTn(99) sfp[2] sfp[1] 3 [4:0x2038fc] bJIFF(62) 0x20391c sfp[2] [4:0x203910] RETo(35) sfp[-1] 1 [5:0x20391c] iSUBn(87) sfp[5] sfp[1] 1 [5:0x203930] FCALL(46) sfp[3] 3 sfp[0] int fibo(int n) [5:0x203940] iSUBn(87) sfp[6] sfp[1] 2 [5:0x203954] FCALL(46) sfp[4] 3 sfp[0] int fibo(int n) [5:0x203964] iADD(84) sfp[-1] sfp[3] sfp[4] [5:0x203970] RET(32)}}}¥end{small}Konoha の大きな特徴は、静的な型付けの特性を活かして、ダイナミック言語より効率のよい実行コードを生成している点です。10年以上にわたる高速化チューニングが施されたPython や世界最速のスクリプティング言語 Lua と比べも、図¥ref{fibo}に示すとおり、数倍以上の実行性能を示しています。¥begin{figure}[h]¥begin{center}%¥includegraphics[width=10cm]{images/teaboard.jpg}¥end{center}¥caption{fibo(36)による性能比較: fibonacci 数列は、数値演算だけでなく、ローカル変数へのアクセスや関数コールなど、プログラミング言語の基礎的な性能を図ることに広く利用されています。}¥label{fibo}¥end{figure}Konoha が大学の研究室生まれであり、プロフェッショナルな開発者が参加していない現状を勘案すれば、より大幅なチューニングも可能と予想される。また、スクリプティング言語の高速化に関しては、学術的なアプローチにより、新しい高速化技法の研究も進められています。== 高いポータビリティ*}Konoha プロジェクトは、開発者が、TRON プロジェクト出身であったこともあり、TRON OS を含めた組み込み分野やユビキタス応用を視野にいれた言語エンジンの開発を行ってきた。そのため、Konoha は、ポータビリティの高いCソースコードで書かれ、UNIX系のOSだけでなく、Windows や TRON(T-Kernel)などで、様々なプラットホームで動作が確認されてきた。(図ｴref{teaboard})¥begin{figure}[h]¥begin{center}¥includegraphics[width=10cm]{images/teaboard.jpg}¥end{center}¥caption{パーソナルメディア製 Teabord (OS:T-Kernel, CPU:ARM, Memory:16Mb)の上で動作する Konoha スクリプティング言語エンジン(2008年頃撮影)}ｴlabel{teaboard}¥end{figure}== 実行前の型検査といつでも実行}型検査とは、型に対する操作、例えば関数コールのとき引数の数や種類が間違っていないか確認することです。ダイナミック言語は、実行時にのみ型検査が行われるため、型エラーが含まれるスクリプトでも実行しないとエラーが発見できない。そのため、全ての実行パスをひとつひとつテスト実行しながら、型エラーを探し、修正する必要があります。Konohaは、静的な型付け言語であるため、スクリプトの実行前に型検査を機械的に、つまりコンパイラが行うことができます。また、スクリプトを実行することなしに、型エラーや潜在的なミスを全て検証するための専用のオプション(-c|)も用意されています。このとき、実際にプログラムが走り始めることはないため、ファイル操作やデータベースが中途半端な状態でプログラムが停止する弊害もない。{{{$ konoha -c sample/err.kkonoha -c err.k  - [err.k:4]:(errata) added return value - [err.k:7]:(error) type error: Int is not string}}}Konohaは、従来の静的な型付け言語と異なる点もあります。"Run anytime" コンパイラ技術を採用し、コンパイル中に型エラーが発見されても、型エラーの部分のみ、実行しても安全なコード（ランタイム例外）に書き換えることで、いつでも実行可能なバイトコードを生成することができます。そのため、コンパイルが通らないため実行できないということはなく、スクリプティング言語の開発しやすさが保たれています。Konohaでは、もしエラー箇所を実行したときは、Source!!|例外が通知されて停止する。プログラマは、エラーを（全部）取り除いてから実行するか、それとも試しに実行させながらバグをとるか、どちらのスタイルの開発でも選ぶことができます。{{{$ konoha sample/err.k - [err.k:7]:(error) type error: Int is not string ** Source!!: Running errors at [err.k:7]}}}== オブジェクト指向}Konoha は、「全てがオブジェクト」という世界観で統一されたオブジェクト指向プログラミング言語です。整数も null}もオブジェクトで表現されています。また、クラスルーム利用において、最先端のオブジェクト指向プログラミングのアイディアを学ぶことができるように設計されています。¥begin{itemize}¥item 名前ベースのクラスシステム¥item 単一継承、インターフェースによるポリモーフィズム¥item ダックタイピングによるポリモーフィズム¥item 総称型（Generics) ¥item メタオブジェクト、アスペクト指向¥item データ変換と相互運用性（Mappable Class) ¥end{itemize}=== クラスを調べる}オブジェクト指向プログラミング言語は、各クラスにその機能性が集約されています。Konoha では、対話モードから man} コマンドで使えば、クラスが提供するオペレーションが表示される。¥begin{small}{{{>>> man IntCLASSNAME  konoha.Int  extends konoha.NumberCONST  Int.MAX: 9223372036854775807  Int.MIN: -9223372036854775808OPERATOR     -x      x != x       x & y       x * y       x + y    x - y       x / y       x < y      x << y      x <= y    x == y       x > y      x >= y      x >> y       x ^ y  x mod y       x | y         x++         x--         |x|       ‾x  METHOD  Int! Int.random(Int n)FORMATTER  %bits %d %f %s %u %x MAPPING  Int    ==> Float    ==> String}}}¥end{small}Konoha は、ソフトウェアモジュールの柔軟性のため、実行時にメソッド等を追加できます。man} コマンドは、実行時の状態を表示するため、メソッドの種類は変更になります。== 活版フォーマッタ*}活版印刷(movable type)は、出版の普及による中世から近代への橋渡しの役割を果たしたため、コンピュータ発明以前の最大の情報技術イノベーションと考えられています。Konoha では、HTMLやXML文書の生成のため広く利用されるテキストフォーマッティングにおいて、活字と同様に再利用性の高い手法を提供することを目指して、組み合わせが自由自在な「活版フォーマッティング(movable formating)」技術を新たに導入しています。基本的なアイディアは、オブジェクト指向モデルに基づく「書式付きフォーマッタ」にあります。フォーマッタは、C 言語のprintf風の書式 (%s, %d|) に似ているが、オブジェクトと書式は出力時にダイナミックバインディングされる。つまり、C言語では型に対して書式が固定的に決まっていたのに対し、Konoha ではint}型でも小数形式で出力したいときは%f|を用いることができます。{{{>>> %s(1)1>>> %03d(1)001>>> %f(1)1.00000>>> %bits(1)00000000 00000000 00000000 00000001}}}オブジェクト単位のフォーマッタを組み合わせて、自由自在にフォーマッティングを行うことができます。{{{>>> p = 9.80>>> `<price> $%.2f{p}</price>`"<price>$9.80</price>"}}}また、フォーマッタはメソッドの一種として、プログラマが自由に定義することもできます。%XML|のような複雑なフォーマッタも作成できます。{{{>>> format %XML (Catalog c) """<product>  <title> %s{c.name}</title>  <price> $%.2f{c.price}</price></product>""">>> %XML(c)<product> <title>Harry Potter DVD</title> <price>$9.80</price></product>}}}注意：フォーマッタは、ストリームへの出力という形でフォーマッティングを行うため、大量のデータを低メモリ消費で変換することができます。詳しくは、「第 ¥ref{formatting} 章 活版フォーマッタ」で述べます。== マッピング機能とデータ変換*}¥begin{comment}Konoha の最大のオブジェクト指向モデルの拡張は、異種データベース翻訳や軽量オントロジ技術をベースにした高度なマッピング機能を導入した点にあります。つまり、簡単にいえば、全ての変換操作はキャスト演算に統合され、データ変換のためのメソッド/関数名を覚える負担から解放される。{{{>>> (String)1"1">>> (Int[])1[1]}}}Konoha は、マッピング意味論を厳密に形式化管理し、複雑なマッピングを自動生成するマッピング推論エンジンを備えています。（以下つづく）¥end{comment}== セマンティック・プログラミング*}