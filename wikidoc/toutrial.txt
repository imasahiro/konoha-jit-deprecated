{{{ html
<h1>Konoha チュートリアルみたいな解説</h1>
}}}

倉光君郎

[[PageOutline(start=1)]]

= Konoha スタイル =

Konoha は、スクリプティング言語の新しい可能性を学術的に探求するために研究開発されている
新しいプログラミング言語です。

こうやって紹介を始めると、さぞかしすごい特徴がある言語だろうと、大いに期待を抱かせてしまうかも知れません。
しかし、その文法はあきれるほどふつうです。

ちょっと、fibonacci 数列を求める関数を書いてみると、

{{{
int fibo(int n) {
  if(n < 3) return 1;
  return fibo(n-1) + fibo(n-2);
}
}}}

正直にいって、C言語やJava言語とほとんど区別つきません。

どうしてこうなっているのかと考えると、それは Konoha の育った環境に原因があります。
Perl や Rubyなど最前線の開発現場から生まれたスクリプティング言語と異なり、
プログラミングが全く苦手な学生たちにわんさか囲まれた環境（大学のこと）では、
ふつうな文法がもっとも受け入れられやすいからです。

もっとも、「C言語やJavaの導入としてプログラミングの授業なんか利用したいな」と
考えていたら、ビョー的にJavaそっくりになってしまった部分もあります。

{{{
// ビョー的な hello, world
void main(String[] args) {
  System.out.println("hello,world");
}
}}}

というわけで、Konoha はふつうに Java だと思って書いていると、
そのまま動くことが多いです。もちろん、細かい違いもありますが、
新しいプログラミング言語を覚えるコストは最小限に抑えられます。

しかし、Java みたいな Konoha スクリプトが増えるにつれて、
何のための「新しいプログラミング言語」開発だったのだろうか？と
ギモンに感じ始めることもあり。

ちなみに、Konoha スタイルの正統な hello, world は、

{{{
OUT << "hello,world" << EOL;
}}}

どちらが書きやすいのかわかりません。しかし、本チュートリアルを読みながら、
Konoha スタイルをマスターしましょう。

== Python にも似ている？

Konoha は、スクリプトファイルを指定せず実行すると、対話モードで起動します。

{{{
$ konoha
Konoha 0.5(toguro) LGPL3.0 (#629, Sep  7 2009 06:58:58)
[GCC 4.0.1 (Apple Inc. build 5490)] on macosx_32 (32, UTF-8)
Options: iconv refc sqlite3 thread regex used_memory:385 kb
>>> 
}}}

もともと、Konoha は Java風の文法で動く、Python みたいなスクリプティング言語を作ろうと
考えていたため、今でも Python へのオマージュとして、そっくりになっています。

対話モードでは、デバッグ用の print 文を用いて、hello,world を書くこともできます。

{{{
>>> print "hello,world"
"hello,world"
}}}

また、man Class を用いれば、Class クラスがサポートしている演算子やメソッドを
使うことを調べることができます。（流石に、dir()ではありません。）

{{{
>>> man String
Class
	konoha.String
Operator
	     x * y       x + y       x - y       x / y     x mod y  
	  x[m..+n]    x[m..<n]     x[m..n]        x[n]     y in? x  
	       |x|  
Method
	String String.concat(Any? v, ...)
	boolean endsWith(String k)
	boolean endsWith:IgnoreCase(String k)
	boolean equals(String k)
	boolean equals:IgnoreCase(String k)
	String format(Any? v, ...)
	Bytes getBytes(String? e)
	int getChar(Int? n)
	int indexOf(String k)
	int indexOf:IgnoreCase(String k)
	int lastIndexOf(String k)
	int lastIndexOf:IgnoreCase(String k)
	String[]? match(Regex? p)
	String new(Bytes b, String? e)
	boolean opMatch(Regex r)
	String replace(String o, String n)
	String[]? split(String? d, Int? i)
	boolean startsWith(String k)
	boolean startsWith:IgnoreCase(String k)
	String substring(Int? o, Int? l)
	String toLower()
	String toUpper()
	String trim()
Formatter
	%k %s 
Mapper
	String
		==> Bytes
		==> Boolean
		--> Int
		--> Float
}}}


[[PageBreak]]
= 変数と型

Konoha のスクリプティング言語としての特徴は、「静的に型付け」されている点です。

これは、変数はコンパイルされるとき、その変数の型が決まっていることを意味します。
今、新しく変数 s に文字列を代入したいと思えば、次のとおり、変数を宣言します。

{{{
String s = "naruto";
}}}

Java プログラマなら、当たり前ですネ。

== 型推論

変数宣言は、「こんなのスクリプティング言語じゃない！！」というお怒りの声多数、
声にもならない失望のため息はそれ以上、とにかくこれは評判がよろしくありません。

そこで、Konoha では型推論のアイディアを採用し、変数宣言を明示的にしなくても、
変数の型を決定されるようにしました。

{{{
>>> s = "naruto";
>>> s
"naruto"
}}}

Konoha は、変数 s はあくまでもString型として静的に型付けされているため、
String 型以外は代入することはできません。

{{{
>>> s = 1;
 - [(shell):4]:(type error) not String
}}}



== null とデフォルト値

Konoha の特徴は、Null 




