¥chapter{レキシカル構造}%プログラミング言語は、「言語」とはよく言ったもので、「言語らしさ」が多く詰まっています。== 文字}%Konoha program are written using Unicode character set. Konoha allows Unicode character in comments and quoted string literals; all elements are restricted to the ASCII character set.Konoha は、はじめから多国語環境での利用を前提として設計されています。文字は、Unicode 規格で定められた文字コードが利用可能であり、スクリプトの記述にはWeb上で標準であるUTF-8エンコーディングを採用しています。また、Konohaの実行環境は、文字コード変換(iconv もしくは相当)機構と統合されており、オペレーティングシステムのローカルなエンコーディングも自動的にUTF8に変換可能して入出力することができます。さて、Konoha は多国語前提と言っておきながら、識別子（変数名、クラス名、メソッド名）にはASCII 文字の利用しか認めていない。これについてちょっと説明を加えておきたい。そもそも、Java 言語が登場したとき、識別子にUnicode 文字、つまり「日本語名」を認めた。これは、たぶん、彼らなりの非欧文圏への親切だったと思うのあるが、それから10年以上を過ぎた現在、日本語で書かれた変数やクラス名をみる機会は全くない。ここから学ぶ教訓は、欧文圏のプログラマにとって「入力すらできない名前」を使わないことも、我々側からの親切であるといえる。== トークン}トークンとは、プログラミング言語の最小の意味単位です。それぞれ、予約語（Konoha文法で定義されたキーワード）、識別子、演算子、リテラル（データ値）などの意味を持つ。ソースコードは、Konoha の文法ルールにしたがって、トークンに分割される。{{{return 0;    // 3つのトークン "return"  "0" ";"return0;     //  ２つのトークン "return0" ";"}}}空白は、ソースコードからトークンを分割するための区切りとなる記号で、空白はいくつ続いても意味はない。タブ(Tab)や改行も空白と同様に扱われる。そのため、プログラマは自由に空白、タブ、改行を用いて読みやすいソースコードを書くことができます。ただし、次節で述べるとおり、改行に関してはひとつだけ留意事項があります。また、次の文字は前後に空白があるものとみなされる。{{{{ } ( ) [ ] ;  ,}}}また、演算子で用いられる記号(+|や*|など)の前後にも空白があるものと解釈される。ただし、読みやすいソースコードを書くため、明示的に空白をいれることが推奨される。{{{a + b                  // 推奨a+b                    // 非推奨}}}%Konoha ignores spaces, tabs, and newlines that appear between tokens in programs. As you can use spaces, tabs, and newlines freely in your programs, you are free to format and indent your programs in a neat and consistent way that makes the code easy to read and understand Note, however, that there is one minor restriction on the placement of line breaks; it is described in the following section.== ステートメント}% Simple statements in Konoha are generally followed by semicolons(;), just as they are in C, C++, and Java. The semicolon servers to separate statements each other. In Konoha, however, you may omit the semicolon if each of your statements is placed on a separate line. For example, the following code would be written without semicolons:ステートメントとは、プログラミング言語における文のことです。Konoha のステートメントは、CやC++, Java と同様に、セミコロン(;)で終わる。{{{a = 3;b = 4;}}}次のように、１行に複数のステートメントを書くこともできます。{{{a = 3; b = 4;}}}% Omitting semicolons is not a good programming practice; you should get in the habit of using them.　Although Konoha theoretically allows line breaks between any two tokens, the fact that automatically inserts semicolons for you causes some exceptions to this rule. Loosely, if you break a line of code in such a way that the line before the break appears to be a complete statement, Konoha may think you omitted the semicolon and insert one for you, altering your meaning. For example, consider the following:ここまでは、CやC++, Java で採用された正しいスタイルのステートメントです。もし、Konoha を学習用として利用している場合、100¥% この正しいスタイルを身につけるべきです。=== セミコロンの省略}多くのスクリプティング言語は、1行の終わりをそのままステートメントの終わりと解釈することが多い。そこでセミコロンを強制することは、Konohaは書きにくい言語となってしまう。そこで、Konoha は、ステートメントの途中に改行がくると、セミコロン(;)を忘れたものと拡大解釈しています。つまり、次の例でも、同様に、２つのステートメントになります。{{{a = 3b = 4}}}こうすると、あちらを立てればこちらが立たずという問題が発生する。Cプログラマは、１行(80文字)に収まりきらないステートメントを改行して読みやすくする習慣があり、このケースではステートメントが勝手に分割されてしまうことになりかねない。{{{print a + b-c;}}}そこで、もしステートメントの途中で改行を入れたときは、２行目以降は字下げしてステートメントが続いていることを明示的に示すことにした。少々面倒な気もするが、多くのCプログラマは読みやすくするため、習慣的に字下げを行っているため、比較的影響が少ないと思われる妥協点です。{{{print a + b	- c;}}} == コメント}% Konoha, like Java, supports both C++ and C-style comments. Any text between // and the end of line is treated as a line comment and is ignored by Konoha. Any comments may span multiple lines and may be nested. The following lines of code are all illegal Konoha comments.Konoha は、C/C++, Java スタイルのコメントを採用しています。// は、行コメントの始まりであり、改行までのテキストがコメントとして無視される。{{{a = b;                        // 行コメント}}}また、C/C++ や Java と同様に、/*| */| で囲むことでコメント化できます。注意すべき点は、KonohaはC言語と異なり、コメントのネストが可能な点です。{{{/* まとめてコメントアウトa = 1;b = 2;  /* コメントの入れ子もOK */*/}}}== リテラル}% The following are all literals:リテラルは、プログラム中に直接あらわれたデータ値のことです。型をもった値として扱われる。次は、基本的なリテラルの例です。{{{12                            // 整数121.2                           // 小数1.2"hello world"                 // テキスト/^world$/                     // 正規表現パターンtrue                          // 論理値 truefalse                         // 論理値 falsenull                          // NULL }}}スクリプティング言語の一般的な特徴は、リテラルが一般的なプログラミング言語に比べ大幅に強化されている点です。Konoha も、データはスクリプトの重要な一部とみなし、配列(Array}), 辞書(DictMap})、そしてオブジェクトのリテラルをサポートしています。{{{[1,2,3]                       // 配列オブジェクト{x :1, y: 2}                  // 辞書オブジェクトC{x: 1, y: 2}                 // クラスCのオブジェクト}}}リテラルは、組み合わせてより複雑なデータを記述することもできます。Konoha のデータリテラルは、JSON などと同様にWeb上でのデータ変換を想定しているため、セキュリティ上の理由から変数や式を含めることはできない。== 識別子}% An identifier is simply a name. In Konoha, identifiers are used to name classes, variables/constants and methods/functions. The rules for legal identifier names are the same in Konoha as they are in Java and many other languages. The first character must be a letter. "Subsequent characters can be a letter, a digit, or, and an underscore (_). These are all legal identifiers:識別子は、名前のことです。Konoha では、識別子は、クラス、変数、メソッド、アノテーションに名づけるために利用される。名前の最初は、アルファベット文字でで始まり、英数字かアンダースコア(_|)が続く。次は、全て正しい識別子の例です。{{{imy_variable_namev9ClassMATH_PI}}}Konoha の識別子の特徴は、Javaプログラミングの名前付けの慣習(naming convension)をルール化し、識別子からその種類を判定できるようにした点です。ただし、識別子の一部はコンテキストから判断するしかない場合があります。=== 変数}変数は、常に英小文字で始まり、英数字、アンダースコアからなる名前をもつ。次は、すべて正しい変数名の例です。{{{n  n2  name  firstName  first_name}}}変数名の先頭にアンダースコアをつけると、それぞれフィールド変数やスクリプト変数をダイレクトに参照する意味となります。{{{_name        // フィールド変数__name       // スクリプト変数}}}=== 定数}定数は、最初に与えられた値が変更されない特別な変数です。英大文字で始まり、英大文字と数字、アンダースコアからなります。次は、正しい定数名の例です。{{{N  N2  NAME  FIRST_NAME}}}%(NOTE) 定数名にアンダースコアが用いられると、グローバル定数となります。クラス定数は、クラス名とあわせて名付けられる定数です。次は、クラス定数の例です。{{{Int.MAX  Math.PI  }}}=== クラス名}クラス名は、常に英大文字で始まり、英数字からなります。アンダースコア(_|)を含めることはできない。次は、全て正しいクラス名です。{{{Int  String  InputStream  C  URN　}}}クラス名は、ローカル定数(アンダースコアなしの定数)と、名前だけから区別することはできない。Konoha コンパイラは、コンテキストによって正しく判断することができるが、ソースコードの読みやすさを考慮に入れたとき、英大文字のみのクラス名(C} や URN})の利用は避けた方がよい。=== 例外名}例外名は、!!|で終わるクラス名です。次は、全て正しい例外名です。{{{Null!!  Security!!   OutOfIndex!!   IO!!}}}Konohaは、Javaプログラマへの互換性を配慮して、クラス名がException}で終わっていた場合、パーサーが自動的に!!| に置き換える。つまり、SecurityException| は、Security!!|となります。逆に、Exception|で終わる名前は、クラス名として用いることはできない。=== メソッド名(関数名)}メソッド名¥footnote{関数は、Script}クラスのメソッドであるため、メソッド名のルールに従う。}は、変数と同様に、英小文字で始まる英数字からなる名前を用います。Konoha は、Java スタイルの(英語の)動詞+名詞でメソッド名を名付けるスタイルを採用し、名詞の始まりで英大文字を用いることを推奨しています。ただし、こればかりはコンパイラでチェックできないので、プログラマの実践に任せるのみです。次は、推奨スタイルに従ったメソッド名です。{{{get getName readLine query}}}メソッド名の途中でアンダースコアを入れることも認められています。ただし、挿入されたアンダースコアは、取り除かれて、続く1文字を英大文字化することで正規化される。{{{get_name                         // getName に正規化get_host_by_name       　        // getHostByName に正規化read_line                        // readLine に正規化}}}Konohaは、C/C++ など他言語で開発されたライブラリをクラスにバインドして利用することが少なくない。この場合、必ずしもJava風の名前慣習に従わないライブラリが多く、既存のライブラリ関数をそのまま利用できた方が便利でもあります。そこで、Konoha では、メソッドや関数をコールするときのみ、英大文字と英小文字の区別をしない。次のどの関数呼び出しも、結局、getPid()|を呼び出すことになります。{{{getpid()GetPid()GET_PID()}}}=== フォーマッタ名}フォーマッタ名は、%|記号で始まる特別なメソッド名です。命名則は、メソッド名にしたがい、利用するときは英大文字/英小文字の区別はない。次は、フォーマッタ名の例です。{{{%s    %4.2f    %dump   %HTML}}}フォーマッタでは、利用のときに限り、%|と名前の間に数字とドット記号(.|)から構成される書式オプションを追加することができます。これは、C言語のprintf書式の慣例にしたがったものです。=== プロパティ変数}プロパティ変数は、実行環境の設定値や環境変数をもった特別な変数名です。$|記号で始まり、英数字及びドット記号(.|)から構成される。次は、正しいプロパティ変数名です。{{{$konoha.version$env.PATH}}}=== アノテーション}アノテーションは、ステートメントに対して注釈やメタデータを与えるときに用います。アノテーション名は、Java 言語と同様に、@|で始まり、英数字からなる名前です。次は、アノテーション名の例です。{{{@Override   @Final   @Doc}}}=== ラベル名}英字で始まりコロン(:)で終わるトークンは、予約語を含め、クラス名、変数名、定数名とは関係なく、ラベルとして扱われる。次は、ラベルの例です。{{{default:    ClassName:   variable:   CONST:}}}コロン(:)の前に空白を入れると、そのトークンはラベルと解釈されない。また、より重要な注意は、ラベルの次は、必ず空白を入れることです。コロン(:)の次に空白がない場合は、連続したトークンとみなされる。{{{name : value      // name はラベルでないname: value       // name: ラベルname:value        // ひとつの識別子}}}== 予約語}%Konoha has a number of reserved keywords. These are words that you cannot use as identifiers (variable names, function names, etc.) in your Konoha programs. The following lists the keywords that have special meaning to Konoha; they are part of the language syntax itself.Konoha は、「識別子としてプログラム中で利用できない」特別なキーワードをいくつか予約しています。次のリストは、Konoha にとって文法の一部、つまり特別な意味をもったキーワードです。¥vspace{1em}¥noindent {¥sfas assert break case catch class continuedefault defined do double else extends false finallyfor foreach from goto if import include interfaceis isa lock namespace new nullpragma printreturn switch  this true try typeof usingvar void where while}¥vspace{1em}いくつかのキーワードは、CやJava, JavaScript などの既存プログラミング言語の記法を解釈するためのエイリアス（別名）として予約されています。{{{abstract                    // @Abstract の別名 boolean	                    // Boolean byte[]                      // Bytesdouble                      // Floatfinal                       // @Finalfloat                       // Floatint                         // Intprivate	                    // @Privateprotected                   // @Protectedpublic                      // @Public}}}