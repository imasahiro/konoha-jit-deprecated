= 名前とリテラル

== 識別子

識別子は、変数やクラスなどにつける名前のことです。
アルファベット文字で始まり、英数字かアンダースコア(_)を続けて名前付けします。

{{{
i              
v9
myVariable             
my_variable    
MATH_PI        
URN            
Urn            
C              

}}}

Konoha は、漢字、ひらがな、カタカナを用いた変数名は使えません。
「日本語くらい使えた方がいいんのではないの？」という意見もありますが、
日本人なら日本語変数名なんて使わないということはご存知のとおりです。

=== 変数、クラス名、定数の区別

Konoha は、
Javaプログラミングで伝統的に用いられてきた名前付け慣習(naming convension)をルール化し、
識別子からクラス名か変数名か定数か、判定できるようにしています。

 * 変数は、英小文字から始まる名前です。
 * 定数は、英大文字から始まり、英大文字のみ含まれる名前です。
 * クラス名は、英大文字から始まり、英小文字が含まれる名前です。

{{{
i              // 変数名
v9             // 変数名
myVariable     // 変数名
my_variable    // 変数名
MATH_PI        // 定数
URN            // 定数
Urn            // クラス名
C              // クラス名　１文字はクラス名

}}}

=== 識別子の正規化

プログラマは、読みやすさのためアンダースコアを名前に含めることが多いですが、
ときどきアンダースコアの有無や位置を忘れてしまうことがあります。

Konoha は、識別子を処理するとき、アンダースコアを除去し、
名前を正規化してマッチングを行っています。
除去されたアンダースコアに続くアルファベットは、英大文字化して扱われます。

{{{
get_name             // getName と同じ
get_host_by_name     // getHostByName と同じ
Class_Name           // ClassName と同じ
BUF_SIZ              // BUFSIZ と同じ

}}}

=== メソッド名と呼び出し名

メソッド名は、変数と同じく、英小文字で始まり英数字からなる名前を用います。

Konoha では、Javaと同じく、
アンダースコアの代わりに英大文字化して連結する命名スタイルを推奨しています。

{{{
readLine      // 推奨スタイル
readline      // 非推奨
read_line     // 非推奨

}}}

さて、スクリプティング言語は、
C/C++などで開発されたライブラリを利用する機会が多くあります。
このようなとき、既存のライブラリ関数名をそのまま利用できた方が
なにかと便利です。

Konohaでは、メソッドや関数のコールに限り、英大文字と英小文字を区別しません。
つまり、メソッド名が getPid であれば、次のどの方法で呼んでも構いません。

{{{
getpid()
GetPid()
GETPID()
GET_PID()

}}}

=== タグ

Konoha は、識別子にタグをつけることができます。

タグは、セマンティックプログラミングにおいて、
クラスの意味を拡張したり、

{{{
Int
Int:km

}}}

バリエーションの異なるメソッドの機能をグループ化するとき、

{{{
equals()
indexOf()
equals:IgnoreCase()
indexOf:IgnoreCase()

}}}

更に、変数名と外部データの属性名などの対応をつけるときに
利用することができます。

{{{
name:名前
age:年齢

}}}

タグは、識別子に比べ、利用できる文字制限が緩和されています。
タグでは、日本語などUTF-8マルチバイト文字列も利用できます。

=== 予約語

Konoha は、いくつかのキーワードを「識別子」と衝突しないため予約しています。
次のリストは、Konoha にとって文法の一部に相当する特別な意味をもった
キーワードとなります。

{{{ html
<blockquote>
as assert break case catch class continue
default defined do double else extends false finally
for foreach from goto if import include interface
is isa lock namespace new null
pragma print
return switch  this true try typeof using
var void where while
</blockquote>
}}}

いくつかのキーワードは、
CやJava, JavaScript などの既存プログラミング言語と互換性のため、
エイリアス（別名）として予約されています。

{{{
abstract                    // @Abstract の別名 
boolean	                    // Boolean 
byte[]                      // Bytes
double                      // Float
final                       // @Final
float                       // Float
int                         // Int
private	                    // @Private
protected                   // @Protected
public                      // @Public

}}}

=== ラベル名

英字で始まりコロン(:)で終わるトークンは、
予約語を含め、クラス名、変数名、定数名とは関係なく、ラベルとして扱われます。

{{{
default:    
ClassName:   
variable:   
CONST:

}}}

コロン(:)の前に空白を入れると、それはラベルだと解釈されません。
また、コロン(:)の次に空白がない場合は、連続したトークン、
つまりタグ付きの識別子とみなされます。

{{{
name : value      // name はラベルでない
name: value       // name: ラベル
name:value        // タグ付きの識別子
}}}

=== 特別な名前

Konoha では、接頭語や接尾語で特別なタイプの名前を使うことができます。

 * 例外名 {{{!!}}}で終わる名前。　{{{　Null!!  Security!!   OutOfIndex!!   IO!!　}}}
 * フォーマッタ名  {{{%}}}で始まる名前 {{{　%s    %4.2f    %dump   %HTML　}}}
 * プロパティ変数 {{{$}}}で始まる名前 {{{ $konoha.version $env.PATH }}}
 * アノテーション　{{{@}}}で始まる名前　{{{　@Override   @Final   @Doc　}}}
 * キー {{{**}}} で始まる名前　{{{ **Class:key }}}

== リテラル

リテラルは、プログラム中に直接あらわれたデータ値のことです。
Konoha は、
一般的なプログラミング言語が持つ標準的なリテラルをサポートしています。

{{{
12                            // 整数12
1.2                           // 小数1.2
"hello world"                 // テキスト
/^world$/                     // 正規表現パターン
true                          // 論理値 true
false                         // 論理値 false
null                          // NULL 

}}}

Konohaで は、データリテラルはスクリプトの重要な一部と考え、
配列, 辞書、そしてオブジェクトなどの値をリテラルとして記述できます。

{{{
[1,2,3]                       // 配列オブジェクト
{x :1, y: 2}                  // 辞書オブジェクト
C{x: 1, y: 2}                 // クラスCのオブジェクト

}}}

では、順番に代表的リテラルをみていきましょう。

=== null

=== 論理値


== 数値リテラル

数値は、ふつうに表記すれば、アルファベットで始まる予約語や識別子と容易に区別がつけられます。
そのため、数値リテラルと言っても、極めて自然な表記となります。
ただし、整数と浮動小数点を区別するため、表記上のルールがあります。

=== 整数リテラル

スクリプティング言語では、
shortやlongなどサイズの異なる整数を使い分ける用途は想定しにくいため、
Konoha ではさっくりと1種類の整数のみサポートすることにしました。
Intクラスは、数値の上限下限を最も気にしなくてすむ64ビット整数を採用しています。
したがって、整数の値の範囲は、
-9,223,372,036,854,775,807から9,223,372,036,854,775,807となります。
つまり、日常生活ではまず足りなくなる心配がありません。

Konohaでは、10進数の整数は、数字の列として書けます。

{{{
0
3
100000000

}}}

10進数表記に加えて、16進表記と2進表記をサポートしています。
間違いのもとになる8進数は採用は見送られました。(0から始めても10進数となります。)

16進表記の整数リテラルは、0xもしくは0Xで始まり、
続いて数字(0-9)もしくは10から15までの数字を表す英字(A-F)が続く形式となります。

{{{
0xff          // 15 * 16 + 15 = 255
0xCAFE911

}}}

クラスルームでは、どういう訳か現在でも2進数をよく教えることが多いため、
Konohaは独自の2進数リテラルとして、
0b もしくは、0Bから始まり、
0もしくは1が続く2進数で整数を与えることができます。

{{{
0b1111        // 0xff = 255 
}}} 

=== Float リテラル

浮動小数点数(floating-point numbers) は、
全て Floatクラスの値として表現されます。
その名前から想像される32ビットのものとは異なり、
IEEE 745 標準で定義された64ビット倍精度形式を用いています。
これらは、C/C++, Java言語の double と同等です。

Float リテラルは、小数点を必ず含めます。
通常、整数パートの数列に始まり、小数点、続いて小数点以下の数列が続く形式となります。
また、eもしくはEによって10のn乗形式で表現することも可能です。

{{{
3.14
2345.789
.33333333333
6.02e23
1.473E-32

}}}

=== 桁取り表記

さて、日常、大きな数字を間違えることなく扱うため、
1000桁ごとにカンマ(,)を入れて表記しますね。
プログラミング言語では、カンマは特殊な意味をもった演算子の一種としているため、
Konohaでは、アンダースコア(_)を数値リテラルの任意の箇所に副作用なく入れることができ、
認められ、カンマの代わりに桁取り表記も可能となります。

{{{
1_0000
9_223_372_036_854_775_807
}}}

=== 意味タグ拡張と単位*

Konohaは、[kbook.semantic セマンティックプログラミング]の機能として、
IntやFloatクラスに対して意味タグを付加することができます。
意味タグは、単位など直感的なタグを用いることが可能であり、
数値リテラルの後置辞として利用することができます。

{{{
32.195km                         // Float:km 
80[km/h]                         // Int[80/km]

}}}

注意：意味タグが定義されていないときは、
意味タグは無視されて、通常の整数、浮動小数点数のリテラルとして扱われます。
読みやすさのために、意味タグを使っても構いません。

== 文字列リテラル

プログラミング言語では、
「識別子」と「データとしての文字列」を区別するため、
文字列をデータ値として扱う文字リテラルが必要となります。
Konoha は、C/C++、Python、C¥#に由来する3種類の文字列リテラル、
さらに独自のリテラルもサポートしています。
ここでは、これらを順番に説明していきます。

=== ダブルクオート

最も基本的な文字列リテラルは、
文字列をダブルクオート(")で囲む形式です。
このリテラルは、C言語を含め、
ほぼ全てのプログラミング言語で広く採用されています。

{{{
""                        // 空文字列
"hello, world"
"3.14"
"Say ¥"hi.¥""             // エスケープ記号
"いろは"                  // Unicode 文字

}}}

文字列リテラルとして、そのまま表現できない文字、
例えば改行やクオート文字"は、
エスケープ記号(¥)を用いて記述することができます。

Konoha では、次の6種類のエスケープシーケンスのみサポートしています。

||sequence||Character represented||
||¥n||改行(LF)||
||¥t||タブ||
||¥¥||¥記号||
||¥'||'シングルクオート (""内)||
||¥"||"ダブルクオート (''内)||
||¥:||:コロン (''内)||

=== 文字列リテラルの連結

文字列リテラルは、
複数並べると、自動的に連結されてひとつの文字列となります。

{{{
"hello" "," "world"　　  // "hello,world"と同じ

}}}

びっくりするかも知れませんが、
C言語を含め、ほとんどのプログラミング言語で採用されています。

Konohaの独自な連結機能は、
文字列リテラルの間に改行があると、改行が追加される点です。

{{{
"hello" ","           // 改行が追加される
"world"

}}}

ちなみに改行を挿入されたくないときは、
+演算子で文字列を連結するしておけば大丈夫です。

=== シングルクオート

Konohaでは、
シングルクオート(')も、タグの(:)の扱いに注意すれば、
文字列リテラルの始まりと終わりとして利用することができます。

シングルクオートを用いると、ダブルクオート(")を含む文字をすっきりと表すことができます。

{{{
'abc'                     // "abc"と同じ
'Say "hi"'                // "Say ¥"hi.¥"" と同じ
'http¥://'                // : はエスケープが必要

}}}

シングルクオートは、正式には「タグ付き文字列」のリテラルとして定義されています。
タグ付き文字列とは、文字列の先頭に'tag:...'|のようなタグを付けて、
文字列の意味を識別し、その意味にしたがって適切なオブジェクトを生成するリテラルです。

{{{
're:s$'                  // 正規表現(Regex)
'file:/tmp/konoha.k'
'isbn:978-4-87311-329-6'
'IO!!:File Not Found'    // 例外(Exception)

}}}

注意：「タグ付き文字列」のタグが未定義な場合は、通常の文字列リテラルとして解釈されます。
ただし、明示的にタグでないことを示すためには、エスケープ(¥:|)する必要があります。
詳しくは、「第¥ref{semantic_programming}章 セマンティックプログラミング」で述べます。

=== バッククオート

バッククオートは、「インライン・フォーマッティング」、
つまり文字リテラル中の書式が評価される特別な文字列リテラルとして用いられます。
次は、%d{}内の式が評価され、%dフォーマッタで整形された文字列が埋め込まれています。

{{{
>>> core =2
>>> `make -j%d{core+1}`
"make -j3"

}}}

もしバッククオートを文字リテラルとして利用するときは、
%文字は、¥%、もしくは%%のようにエスケープ処理が必要になります。
それらに注意すれば、バッククオート(`)も、
文字列リテラルの始まりと終わりの記号として利用できます。
シングルクオートとダブルクオートが混在する文字列をすっきりと書くことができます。

{{{
`Naruto said, "I'm a ninja."`

}}}

=== トリプルクオート

トリプルクオートは、
Python に由来するテキスト用の文字リテラルです。
!''' もしくは、""" で囲まれたテキストは、
改行やタブ文字もそのまま文字列として扱われます。
ただし、エスケープシーケンスも有効になります。

{{{
'''
This is a rather long string containing
several lines of text just as you would do in C.
   Note that whitespace at the beginning of the 
   line is significant.
'''

}}}

また、トリプルバッククオート(```)を用いれば、ご想像のとおり、
インラインフォーマッティングも有効になります。

{{{
```
configure
make -j%d{core+1}
```

}}}

Konoha では、読みやすさを向上するため、
トリプルクオートが改行から始まる場合は、その改行は無視されます。
つまり、上記のトリプルクオート文字列は、"c"から始まることになります。

=== RAW 文字列

RAW文字列とは、エスケープシーケンスを無視した文字列リテラルです。
Konoha は、C¥# に由来する記法を採用し、
文字リテラルの前に@を付加するとRAW文字列として用いられます。

{{{
@ "C:¥My Document¥Programming¥Konoha"

}}}

=== 行リテラル

# で始まる行は、コメントかなという予想を裏切り、
その行の終わりまでをそのまま文字列として解釈されます。
ただし、#直後の空白(スペース)だけは、
読みやすさのため挿入と解釈され、それは無視されます。

行リテラルは、
バッククオートと同じく、「インライン・フォーマッティング」を解釈します。

{{{
# make -j3         　　  // "make -j3"と同じ
# make -j%d{core+1}
}}}

行リテラルは、文字列リテラルの連結のところで述べるとおり、
ドキュメントや他言語のスクリプトを（読みやすく）書くための記法です。

{{{
>>> s = # make -j3
>>> s
"make -j3"

}}}


Konohaでは、
メソッドや関数の第一パラメータに文字列リテラルを書くとき、
関数コール演算子()を省略することができます。

さて、どちらが読みやすいか比べてみましょう。

{{{
db.query
   # create table book (
   #    name char[20];
   #    title char[80];
   # );
}}}

{{{
db.query('''
create table book (
name char[20];
title char[80];
);''')

}}}



[[include(KbookIndex)]]
[[include(KbookFooter)]]
