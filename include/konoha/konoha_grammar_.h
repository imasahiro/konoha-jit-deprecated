// THIS FILE WAS AUTOMATICALLY GENERATED

#ifndef GAMMA_MACRO
#define GAMMA_MACRO 1

/* ======================================================================== */
/* TT_MACRO */
#define TT_PRAGMA                       ((knh_term_t)0)
#define TT_NAMESPACE                    ((knh_term_t)1)
#define TT_SCRIPT                       ((knh_term_t)2)
#define TT_INCLUDE                      ((knh_term_t)3)
#define TT_IMPORT                       ((knh_term_t)4)
#define TT_USING                        ((knh_term_t)5)
#define TT_CLASS                        ((knh_term_t)6)
#define TT_METHOD                       ((knh_term_t)7)
#define TT_FORMAT                       ((knh_term_t)8)
#define TT_RETURN                       ((knh_term_t)9)
#define TT_YEILD                        ((knh_term_t)10)
#define TT_IF                           ((knh_term_t)11)
#define TT_SWITCH                       ((knh_term_t)12)
#define TT_CASE                         ((knh_term_t)13)
#define TT_WHILE                        ((knh_term_t)14)
#define TT_DO                           ((knh_term_t)15)
#define TT_FOR                          ((knh_term_t)16)
#define TT_FOREACH                      ((knh_term_t)17)
#define TT_BREAK                        ((knh_term_t)18)
#define TT_CONTINUE                     ((knh_term_t)19)
#define TT_GOTO                         ((knh_term_t)20)
#define TT_TRY                          ((knh_term_t)21)
#define TT_CATCH                        ((knh_term_t)22)
#define TT_THROW                        ((knh_term_t)23)
#define TT_LSEND                        ((knh_term_t)24)
#define TT_PRINT                        ((knh_term_t)25)
#define TT_ASSERT                       ((knh_term_t)26)
#define TT_CHECKIN                      ((knh_term_t)27)
#define TT_REGISTER                     ((knh_term_t)28)
#define TT_SELECT                       ((knh_term_t)29)
#define TT_GO                           ((knh_term_t)30)
#define TT_EXTENDS                      ((knh_term_t)31)
#define TT_IMPLEMENTS                   ((knh_term_t)32)
#define TT_ELSE                         ((knh_term_t)33)
#define TT_DEFAULT                      ((knh_term_t)34)
#define TT_FINALLY                      ((knh_term_t)35)
#define TT_DOTS                         ((knh_term_t)36)
#define TT_EXPT                         ((knh_term_t)37)
#define TT_COMMA                        ((knh_term_t)38)
#define TT_SEMICOLON                    ((knh_term_t)39)
#define TT_ASIS                         ((knh_term_t)40)
#define TT_FUNCTION                     ((knh_term_t)41)
#define TT_BLOCK                        ((knh_term_t)42)
#define TT_NEW                          ((knh_term_t)43)
#define TT_NULL                         ((knh_term_t)44)
#define TT_VOID                         ((knh_term_t)45)
#define TT_VAR                          ((knh_term_t)46)
#define TT_TRUE                         ((knh_term_t)47)
#define TT_FALSE                        ((knh_term_t)48)
#define TT_BYTE                         ((knh_term_t)49)
#define TT_TYPEOF                       ((knh_term_t)50)
#define TT_BRACE                        ((knh_term_t)51)
#define TT_PARENTHESIS                  ((knh_term_t)52)
#define TT_BRANCET                      ((knh_term_t)53)
#define TT_DOT                          ((knh_term_t)54)
#define TT_COLON                        ((knh_term_t)55)
#define TT_ARROW                        ((knh_term_t)56)
#define TT_FUNCARROW                    ((knh_term_t)57)
#define TT_LSFTE                        ((knh_term_t)58)
#define TT_RSFTE                        ((knh_term_t)59)
#define TT_ADDE                         ((knh_term_t)60)
#define TT_SUBE                         ((knh_term_t)61)
#define TT_DIVE                         ((knh_term_t)62)
#define TT_MODE                         ((knh_term_t)63)
#define TT_MULE                         ((knh_term_t)64)
#define TT_LANDE                        ((knh_term_t)65)
#define TT_LORE                         ((knh_term_t)66)
#define TT_ALTLET                       ((knh_term_t)67)
#define TT_NUM                          ((knh_term_t)68)
#define TT_STR                          ((knh_term_t)69)
#define TT_TSTR                         ((knh_term_t)70)
#define TT_ESTR                         ((knh_term_t)71)
#define TT_REGEX                        ((knh_term_t)72)
#define TT_DOC                          ((knh_term_t)73)
#define TT_METAN                        ((knh_term_t)74)
#define TT_PROPN                        ((knh_term_t)75)
#define TT_URN                          ((knh_term_t)76)
#define TT_NAME                         ((knh_term_t)77)
#define TT_UNAME                        ((knh_term_t)78)
#define TT_FUNCNAME                     ((knh_term_t)79)
#define TT_FMT                          ((knh_term_t)80)
#define TT_TYPE                         ((knh_term_t)81)
#define TT_MN                           ((knh_term_t)82)
#define TT_CID                          ((knh_term_t)83)
#define TT_CONST                        ((knh_term_t)84)
#define TT_STMT                         ((knh_term_t)85)
#define TT_SYSVAL                       ((knh_term_t)86)
#define TT_LOCAL                        ((knh_term_t)87)
#define TT_STACK                        ((knh_term_t)88)
#define TT_FIELD                        ((knh_term_t)89)
#define TT_ERR                          ((knh_term_t)90)
#define TT_EOT                          ((knh_term_t)91)
#define TT_LET                          ((knh_term_t)92)
#define TT_SEND                         ((knh_term_t)93)
#define TT_ALT                          ((knh_term_t)94)
#define TT_QUESTION                     ((knh_term_t)95)
#define TT_OR                           ((knh_term_t)96)
#define TT_AND                          ((knh_term_t)97)
#define TT_NOT                          ((knh_term_t)98)
#define TT_EXISTS                       ((knh_term_t)99)
#define TT_IS                           ((knh_term_t)100)
#define TT_OF                           ((knh_term_t)101)
#define TT_ISA                          ((knh_term_t)102)
#define TT_IN                           ((knh_term_t)103)
#define TT_MATCH                        ((knh_term_t)104)
#define TT_EQ                           ((knh_term_t)105)
#define TT_NEQ                          ((knh_term_t)106)
#define TT_LT                           ((knh_term_t)107)
#define TT_LTE                          ((knh_term_t)108)
#define TT_GT                           ((knh_term_t)109)
#define TT_GTE                          ((knh_term_t)110)
#define TT_FROM                         ((knh_term_t)111)
#define TT_WHERE                        ((knh_term_t)112)
#define TT_TO                           ((knh_term_t)113)
#define TT_UNTIL                        ((knh_term_t)114)
#define TT_LSFT                         ((knh_term_t)115)
#define TT_RSFT                         ((knh_term_t)116)
#define TT_ADD                          ((knh_term_t)117)
#define TT_SUB                          ((knh_term_t)118)
#define TT_DIV                          ((knh_term_t)119)
#define TT_MOD                          ((knh_term_t)120)
#define TT_MUL                          ((knh_term_t)121)
#define TT_LAND                         ((knh_term_t)122)
#define TT_LOR                          ((knh_term_t)123)
#define TT_XOR                          ((knh_term_t)124)
#define TT_LNOT                         ((knh_term_t)125)
#define TT_NEXT                         ((knh_term_t)126)
#define TT_PREV                         ((knh_term_t)127)
#define TT_PATH                         ((knh_term_t)128)
#define TT_ITR                          ((knh_term_t)129)
#define TT_TMUL                         ((knh_term_t)130)
#define TT_TADD                         ((knh_term_t)131)
#define TT_ADDR                         ((knh_term_t)132)
#define TT_TSUB                         ((knh_term_t)133)
#define K_TOKEN_MAXSIZ                  ((knh_term_t)134)

/* ------------------------------------------------------------------------ */
#define STT_PRAGMA                      ((knh_term_t)134)
#define STT_NAMESPACE                   ((knh_term_t)135)
#define STT_SCRIPT                      ((knh_term_t)136)
#define STT_INCLUDE                     ((knh_term_t)137)
#define STT_IMPORT                      ((knh_term_t)138)
#define STT_USING                       ((knh_term_t)139)
#define STT_CLASS                       ((knh_term_t)140)
#define STT_METHOD                      ((knh_term_t)141)
#define STT_FORMAT                      ((knh_term_t)142)
#define STT_RETURN                      ((knh_term_t)143)
#define STT_YEILD                       ((knh_term_t)144)
#define STT_IF                          ((knh_term_t)145)
#define STT_SWITCH                      ((knh_term_t)146)
#define STT_CASE                        ((knh_term_t)147)
#define STT_WHILE                       ((knh_term_t)148)
#define STT_DO                          ((knh_term_t)149)
#define STT_FOR                         ((knh_term_t)150)
#define STT_FOREACH                     ((knh_term_t)151)
#define STT_BREAK                       ((knh_term_t)152)
#define STT_CONTINUE                    ((knh_term_t)153)
#define STT_GOTO                        ((knh_term_t)154)
#define STT_TRY                         ((knh_term_t)155)
#define STT_CATCH                       ((knh_term_t)156)
#define STT_THROW                       ((knh_term_t)157)
#define STT_LSEND                       ((knh_term_t)158)
#define STT_PRINT                       ((knh_term_t)159)
#define STT_ASSERT                      ((knh_term_t)160)
#define STT_CHECKIN                     ((knh_term_t)161)
#define STT_REGISTER                    ((knh_term_t)162)
#define STT_SELECT                      ((knh_term_t)163)
#define STT_GO                          ((knh_term_t)164)
#define STT_FUNCTION                    ((knh_term_t)165)
#define STT_BLOCK                       ((knh_term_t)166)
#define STT_DONE                        ((knh_term_t)167)
#define STT_DECL                        ((knh_term_t)168)
#define STT_LETM                        ((knh_term_t)169)
#define STT_PUSHM                       ((knh_term_t)170)
#define STT_CMD                         ((knh_term_t)171)
#define STT_EXTRA                       ((knh_term_t)172)
#define STT_ERR                         ((knh_term_t)173)
#define STT_LET                         ((knh_term_t)174)
#define STT_NEW                         ((knh_term_t)175)
#define STT_TCAST                       ((knh_term_t)176)
#define STT_FUNC                        ((knh_term_t)177)
#define STT_CALL                        ((knh_term_t)178)
#define STT_PCALL                       ((knh_term_t)179)
#define STT_MT                          ((knh_term_t)180)
#define STT_FMT                         ((knh_term_t)181)
#define STT_OP                          ((knh_term_t)182)
#define STT_TRI                         ((knh_term_t)183)
#define STT_ALT                         ((knh_term_t)184)
#define STT_AND                         ((knh_term_t)185)
#define STT_OR                          ((knh_term_t)186)
#define STT_CALL1                       ((knh_term_t)187)
#define K_STMT_MAXSIZ                   ((knh_term_t)188)

/* ------------------------------------------------------------------------ */
#define MN_opLET                        ((knh_methodn_t)0)
#define MN_opSEND                       ((knh_methodn_t)1)
#define MN_opALT                        ((knh_methodn_t)2)
#define MN_opQ                          ((knh_methodn_t)3)
#define MN_opOR                         ((knh_methodn_t)4)
#define MN_opAND                        ((knh_methodn_t)5)
#define MN_opNOT                        ((knh_methodn_t)6)
#define MN_opEXISTS                     ((knh_methodn_t)7)
#define MN_opIS                         ((knh_methodn_t)8)
#define MN_opOF                         ((knh_methodn_t)9)
#define MN_opISA                        ((knh_methodn_t)10)
#define MN_opHAS                        ((knh_methodn_t)11)
#define MN_opCASE                       ((knh_methodn_t)12)
#define MN_opEQ                         ((knh_methodn_t)13)
#define MN_opNOTEQ                      ((knh_methodn_t)14)
#define MN_opLT                         ((knh_methodn_t)15)
#define MN_opLTE                        ((knh_methodn_t)16)
#define MN_opGT                         ((knh_methodn_t)17)
#define MN_opGTE                        ((knh_methodn_t)18)
#define MN_opFROM                       ((knh_methodn_t)19)
#define MN_opWHERE                      ((knh_methodn_t)20)
#define MN_opTO                         ((knh_methodn_t)21)
#define MN_opUNTIL                      ((knh_methodn_t)22)
#define MN_opLSFT                       ((knh_methodn_t)23)
#define MN_opRSFT                       ((knh_methodn_t)24)
#define MN_opADD                        ((knh_methodn_t)25)
#define MN_opSUB                        ((knh_methodn_t)26)
#define MN_opDIV                        ((knh_methodn_t)27)
#define MN_opMOD                        ((knh_methodn_t)28)
#define MN_opMUL                        ((knh_methodn_t)29)
#define MN_opLAND                       ((knh_methodn_t)30)
#define MN_opLOR                        ((knh_methodn_t)31)
#define MN_opLXOR                       ((knh_methodn_t)32)
#define MN_opLNOT                       ((knh_methodn_t)33)
#define MN_opNEXT                       ((knh_methodn_t)34)
#define MN_opPREV                       ((knh_methodn_t)35)
#define MN_opPATH                       ((knh_methodn_t)36)
#define MN_opITR                        ((knh_methodn_t)37)
#define MN_opEXPAND                     ((knh_methodn_t)38)
#define MN_opPLUS                       ((knh_methodn_t)39)
#define MN_opADDR                       ((knh_methodn_t)40)
#define MN_opNEG                        ((knh_methodn_t)41)
#define MN_OPSIZE                       ((knh_methodn_t)42)

/* ------------------------------------------------------------------------ */


#endif/*GAMMA_MACRO*/

#ifdef K_USING_LOADDATA

typedef struct {
	char *name;
	knh_uintptr_t tt;
} knh_TokenData_t;

static knh_TokenData_t knh_TokenData[] = {
	{"-", TT_SUB}, 
	{"=~", TT_MATCH}, 
	{"%=", TT_MODE}, 
	{"go", TT_KEYWORD(TT_GO)}, 
	{"(", TT_PARENTHESIS}, 
	{",", TT_COMMA}, 
	{"to", TT_TO}, 
	{"finally", TT_KEYWORD(TT_FINALLY)}, 
	{"extends", TT_KEYWORD(TT_EXTENDS)}, 
	{"include", TT_KEYWORD(TT_INCLUDE)}, 
	{"<", TT_LT}, 
	{"...", TT_DOTS}, 
	{"return", TT_KEYWORD(TT_RETURN)}, 
	{"format", TT_FORMAT}, 
	{"==", TT_EQ}, 
	{"void", TT_KEYWORD(TT_VOID)}, 
	{"|=", TT_LORE}, 
	{"break", TT_KEYWORD(TT_BREAK)}, 
	{"***", TT_TMUL}, 
	{"new", TT_KEYWORD(TT_NEW)}, 
	{"not", TT_NOT}, 
	{"using", TT_KEYWORD(TT_USING)}, 
	{"instanceof", TT_OF}, 
	{"--", TT_PREV}, 
	{"?\?=", TT_ALTLET}, 
	{"try", TT_KEYWORD(TT_TRY)}, 
	{"continue", TT_KEYWORD(TT_CONTINUE)}, 
	{"-=", TT_SUBE}, 
	{"->", TT_ARROW}, 
	{"where", TT_WHERE}, 
	{"|", TT_LOR}, 
	{"exists", TT_EXISTS}, 
	{"is?", TT_IS}, 
	{"for", TT_KEYWORD(TT_FOR)}, 
	{"<<<", TT_LSFT}, 
	{"+", TT_ADD}, 
	{"lsend", TT_LSEND}, 
	{"/", TT_DIV}, 
	{"print", TT_KEYWORD(TT_PRINT)}, 
	{"import", TT_KEYWORD(TT_IMPORT)}, 
	{";", TT_SEMICOLON}, 
	{"method", TT_METHOD}, 
	{"?", TT_QUESTION}, 
	{"goto", TT_KEYWORD(TT_GOTO)}, 
	{"&=", TT_LANDE}, 
	{"[", TT_BRANCET}, 
	{"throw", TT_KEYWORD(TT_THROW)}, 
	{"_", TT_ASIS}, 
	{"++", TT_NEXT}, 
	{"&", TT_LAND}, 
	{"{", TT_BRACE}, 
	{"or", TT_OR}, 
	{"+=", TT_ADDE}, 
	{"!!", TT_EXPT}, 
	{">=", TT_GTE}, 
	{">>", TT_RSFT}, 
	{"isa?", TT_ISA}, 
	{"+++", TT_TADD}, 
	{"!=", TT_NEQ}, 
	{"byte", TT_KEYWORD(TT_BYTE)}, 
	{"select", TT_KEYWORD(TT_SELECT)}, 
	{"?\?", TT_ALT}, 
	{"from", TT_FROM}, 
	{"..", TT_ITR}, 
	{"script", TT_KEYWORD(TT_SCRIPT)}, 
	{"*", TT_MUL}, 
	{">>=", TT_RSFTE}, 
	{".", TT_DOT}, 
	{"var", TT_KEYWORD(TT_VAR)}, 
	{":", TT_COLON}, 
	{"until", TT_UNTIL}, 
	{">", TT_GT}, 
	{"function", TT_KEYWORD(TT_FUNCTION)}, 
	{"yeild", TT_KEYWORD(TT_YEILD)}, 
	{"else", TT_KEYWORD(TT_ELSE)}, 
	{"assert", TT_KEYWORD(TT_ASSERT)}, 
	{"pragma", TT_KEYWORD(TT_PRAGMA)}, 
	{"catch", TT_KEYWORD(TT_CATCH)}, 
	{"&&&", TT_ADDR}, 
	{"true", TT_KEYWORD(TT_TRUE)}, 
	{"^", TT_XOR}, 
	{"case", TT_KEYWORD(TT_CASE)}, 
	{"default", TT_KEYWORD(TT_DEFAULT)}, 
	{"while", TT_KEYWORD(TT_WHILE)}, 
	{"typeof", TT_KEYWORD(TT_TYPEOF)}, 
	{"~", TT_LNOT}, 
	{"and", TT_AND}, 
	{"false", TT_KEYWORD(TT_FALSE)}, 
	{"do", TT_KEYWORD(TT_DO)}, 
	{"<<", TT_SEND}, 
	{"<=", TT_LTE}, 
	{"---", TT_TSUB}, 
	{"null", TT_KEYWORD(TT_NULL)}, 
	{"if", TT_KEYWORD(TT_IF)}, 
	{"%", TT_MOD}, 
	{"namespace", TT_KEYWORD(TT_NAMESPACE)}, 
	{"/=", TT_DIVE}, 
	{"=>", TT_FUNCARROW}, 
	{"foreach", TT_KEYWORD(TT_FOREACH)}, 
	{"=", TT_LET}, 
	{"checkin", TT_KEYWORD(TT_CHECKIN)}, 
	{"*=", TT_MULE}, 
	{"in?", TT_IN}, 
	{"**", TT_PATH}, 
	{"class", TT_KEYWORD(TT_CLASS)}, 
	{"implements", TT_KEYWORD(TT_IMPLEMENTS)}, 
	{"<<=", TT_LSFTE}, 
	{"register", TT_KEYWORD(TT_REGISTER)}, 
	{"switch", TT_KEYWORD(TT_SWITCH)}, 
	{"block", TT_BLOCK}, 
	{NULL, 0}
};

static void knh_loadTokenData(Ctx *ctx)
{
	knh_TokenData_t *data = knh_TokenData;
	knh_DictSet_t *ds = DP(ctx->sys)->tokenDictSet;
	while(data->name != NULL) {
		knh_DictSet_set(ctx, ds, new_T(data->name), data->tt);
		data++;
	}
}

typedef struct {
	char *name;
	char *alias;
} knh_AliasData_t;

static knh_AliasData_t knh_AliasData[] = {
	{"int", "Int"}, 
	{"||", "or"}, 
	{"float", "Float"}, 
	{"private", "@Private"}, 
	{"char", "Int"}, 
	{"boolean", "Boolean"}, 
	{"static", "@Static"}, 
	{"virtual", "@Virtual"}, 
	{"NULL", "null"}, 
	{"TRUE", "true"}, 
	{"!", "not"}, 
	{"long", "Int"}, 
	{"Integer", "Int"}, 
	{"True", "true"}, 
	{"final", "@Final"}, 
	{"string", "String"}, 
	{"&&", "and"}, 
	{"False", "false"}, 
	{"mod", "%"}, 
	{"===", "is"}, 
	{"short", "Int"}, 
	{"FALSE", "false"}, 
	{"double", "Float"}, 
	{"ArrayList", "Array"}, 
	{"public", "@Public"}, 
	{"def", "var"}, 
	{NULL, NULL}
};

static void knh_loadAliasTokenData(Ctx *ctx)
{
	knh_AliasData_t *data = knh_AliasData;
	knh_DictMap_t *dm = new_DictMap0(ctx, 0);
	KNH_INITv(DP(ctx->share->mainns)->aliasDictMapNULL, dm);
	while(data->name != NULL) {
		knh_DictMap_set(ctx, dm, new_T(data->name), UP(new_T(data->alias)));
		data++;
	}
}

#endif/*K_USING_LOADDATA*/

#ifdef K_USING_TERMCODE
/***********************************************
static knh_term_t knh_bytes_parseToken(Ctx *ctx, knh_bytes_t t)
{
	knh_uintptr_t n = knh_DictSet_get__b(DP(ctx->sys)->tokenDictSet, t);
	if(n > 0) {
		knh_term_t tt = (knh_term_t)(n);
		return TT_UNMASK(tt);
	}
	return TT_EOT;
}

static int knh_bytes_isKeyword(Ctx *ctx, knh_bytes_t t)
{
	knh_uintptr_t n = knh_DictSet_get__b(DP(ctx->sys)->tokenDictSet, t);
	if(n > 0) {
		knh_term_t tt = (knh_term_t)(n);
		return TT_ISKEYWORD(tt);
	}
	return TT_EOT;
}
********************************************/

#ifndef K_USING_SMALLFOOTPRINT
static char* knh_tokens[] = {
	"pragma", /* TT_PRAGMA */
	"namespace", /* TT_NAMESPACE */
	"script", /* TT_SCRIPT */
	"include", /* TT_INCLUDE */
	"import", /* TT_IMPORT */
	"using", /* TT_USING */
	"class", /* TT_CLASS */
	"method", /* TT_METHOD */
	"format", /* TT_FORMAT */
	"return", /* TT_RETURN */
	"yeild", /* TT_YEILD */
	"if", /* TT_IF */
	"switch", /* TT_SWITCH */
	"case", /* TT_CASE */
	"while", /* TT_WHILE */
	"do", /* TT_DO */
	"for", /* TT_FOR */
	"foreach", /* TT_FOREACH */
	"break", /* TT_BREAK */
	"continue", /* TT_CONTINUE */
	"goto", /* TT_GOTO */
	"try", /* TT_TRY */
	"catch", /* TT_CATCH */
	"throw", /* TT_THROW */
	"lsend", /* TT_LSEND */
	"print", /* TT_PRINT */
	"assert", /* TT_ASSERT */
	"checkin", /* TT_CHECKIN */
	"register", /* TT_REGISTER */
	"select", /* TT_SELECT */
	"go", /* TT_GO */
	"extends", /* TT_EXTENDS */
	"implements", /* TT_IMPLEMENTS */
	"else", /* TT_ELSE */
	"default", /* TT_DEFAULT */
	"finally", /* TT_FINALLY */
	"...", /* TT_DOTS */
	"!!", /* TT_EXPT */
	",", /* TT_COMMA */
	";", /* TT_SEMICOLON */
	"_", /* TT_ASIS */
	"function", /* TT_FUNCTION */
	"block", /* TT_BLOCK */
	"new", /* TT_NEW */
	"null", /* TT_NULL */
	"void", /* TT_VOID */
	"var", /* TT_VAR */
	"true", /* TT_TRUE */
	"false", /* TT_FALSE */
	"byte", /* TT_BYTE */
	"typeof", /* TT_TYPEOF */
	"{", /* TT_BRACE */
	"(", /* TT_PARENTHESIS */
	"[", /* TT_BRANCET */
	".", /* TT_DOT */
	":", /* TT_COLON */
	"->", /* TT_ARROW */
	"=>", /* TT_FUNCARROW */
	"<<=", /* TT_LSFTE */
	">>=", /* TT_RSFTE */
	"+=", /* TT_ADDE */
	"-=", /* TT_SUBE */
	"/=", /* TT_DIVE */
	"%=", /* TT_MODE */
	"*=", /* TT_MULE */
	"&=", /* TT_LANDE */
	"|=", /* TT_LORE */
	"?\?=", /* TT_ALTLET */
	"TT_NUM", /* TT_NUM */
	"TT_STR", /* TT_STR */
	"TT_TSTR", /* TT_TSTR */
	"TT_ESTR", /* TT_ESTR */
	"TT_REGEX", /* TT_REGEX */
	"TT_DOC", /* TT_DOC */
	"TT_METAN", /* TT_METAN */
	"TT_PROPN", /* TT_PROPN */
	"TT_URN", /* TT_URN */
	"TT_NAME", /* TT_NAME */
	"TT_UNAME", /* TT_UNAME */
	"TT_FUNCNAME", /* TT_FUNCNAME */
	"TT_FMT", /* TT_FMT */
	"TT_TYPE", /* TT_TYPE */
	"TT_MN", /* TT_MN */
	"TT_CID", /* TT_CID */
	"TT_CONST", /* TT_CONST */
	"TT_STMT", /* TT_STMT */
	"TT_SYSVAL", /* TT_SYSVAL */
	"TT_LOCAL", /* TT_LOCAL */
	"TT_STACK", /* TT_STACK */
	"TT_FIELD", /* TT_FIELD */
	"TT_ERR", /* TT_ERR */
	"TT_EOT", /* TT_EOT */
	"=", /* TT_LET */
	"<<", /* TT_SEND */
	"?\?", /* TT_ALT */
	"?", /* TT_QUESTION */
	"or", /* TT_OR */
	"and", /* TT_AND */
	"not", /* TT_NOT */
	"exists", /* TT_EXISTS */
	"is?", /* TT_IS */
	"instanceof", /* TT_OF */
	"isa?", /* TT_ISA */
	"in?", /* TT_IN */
	"=~", /* TT_MATCH */
	"==", /* TT_EQ */
	"!=", /* TT_NEQ */
	"<", /* TT_LT */
	"<=", /* TT_LTE */
	">", /* TT_GT */
	">=", /* TT_GTE */
	"from", /* TT_FROM */
	"where", /* TT_WHERE */
	"to", /* TT_TO */
	"until", /* TT_UNTIL */
	"<<<", /* TT_LSFT */
	">>", /* TT_RSFT */
	"+", /* TT_ADD */
	"-", /* TT_SUB */
	"/", /* TT_DIV */
	"%", /* TT_MOD */
	"*", /* TT_MUL */
	"&", /* TT_LAND */
	"|", /* TT_LOR */
	"^", /* TT_XOR */
	"~", /* TT_LNOT */
	"++", /* TT_NEXT */
	"--", /* TT_PREV */
	"**", /* TT_PATH */
	"..", /* TT_ITR */
	"***", /* TT_TMUL */
	"+++", /* TT_TADD */
	"&&&", /* TT_ADDR */
	"---", /* TT_TSUB */
	NULL
};
#endif/*SMALLFOOTPRINT*/

#ifndef K_USING_SMALLFOOTPRINT
static char* knh_stmts[] = {
	"pragma", /* STT_PRAGMA */
	"namespace", /* STT_NAMESPACE */
	"script", /* STT_SCRIPT */
	"include", /* STT_INCLUDE */
	"import", /* STT_IMPORT */
	"using", /* STT_USING */
	"class", /* STT_CLASS */
	"method", /* STT_METHOD */
	"format", /* STT_FORMAT */
	"return", /* STT_RETURN */
	"yeild", /* STT_YEILD */
	"if", /* STT_IF */
	"switch", /* STT_SWITCH */
	"case", /* STT_CASE */
	"while", /* STT_WHILE */
	"do", /* STT_DO */
	"for", /* STT_FOR */
	"foreach", /* STT_FOREACH */
	"break", /* STT_BREAK */
	"continue", /* STT_CONTINUE */
	"goto", /* STT_GOTO */
	"try", /* STT_TRY */
	"catch", /* STT_CATCH */
	"throw", /* STT_THROW */
	"lsend", /* STT_LSEND */
	"print", /* STT_PRINT */
	"assert", /* STT_ASSERT */
	"checkin", /* STT_CHECKIN */
	"register", /* STT_REGISTER */
	"select", /* STT_SELECT */
	"go", /* STT_GO */
	"function", /* STT_FUNCTION */
	"block", /* STT_BLOCK */
	"STT_DONE", /* STT_DONE */
	"STT_DECL", /* STT_DECL */
	"STT_LETM", /* STT_LETM */
	"STT_PUSHM", /* STT_PUSHM */
	"STT_CMD", /* STT_CMD */
	"STT_EXTRA", /* STT_EXTRA */
	"STT_ERR", /* STT_ERR */
	"STT_LET", /* STT_LET */
	"STT_NEW", /* STT_NEW */
	"STT_TCAST", /* STT_TCAST */
	"STT_FUNC", /* STT_FUNC */
	"STT_CALL", /* STT_CALL */
	"STT_PCALL", /* STT_PCALL */
	"STT_MT", /* STT_MT */
	"STT_FMT", /* STT_FMT */
	"STT_OP", /* STT_OP */
	"STT_TRI", /* STT_TRI */
	"STT_ALT", /* STT_ALT */
	"STT_AND", /* STT_AND */
	"STT_OR", /* STT_OR */
	"STT_CALL1", /* STT_CALL1 */
	NULL
};
#endif/*SMALLFOOTPRINT*/

char *TT_tochar(knh_term_t tt)
{
	if(tt < K_TOKEN_MAXSIZ) {
#ifdef K_USING_SMALLFOOTPRINT
		return "TT";
#else
		return knh_tokens[tt];
#endif
	}
	else {
#ifdef K_USING_SMALLFOOTPRINT
		return "STT";
#else
		return knh_stmts[tt - K_TOKEN_MAXSIZ];
#endif
	}
}

typedef struct { 
	char *opname;
	int priority;
} knh_opdata_t;

static knh_opdata_t knh_opdata[] = {
	{"=", 3 /* TT_LET */}, 
	{"<<", 2 /* TT_SEND */}, 
	{"?\?", 4 /* TT_ALT */}, 
	{"?", 4 /* TT_QUESTION */}, 
	{"or", 5 /* TT_OR */}, 
	{"and", 6 /* TT_AND */}, 
	{"not", 7 /* TT_NOT */}, 
	{"exists", 7 /* TT_EXISTS */}, 
	{"is?", 9 /* TT_IS */}, 
	{"instanceof", 9 /* TT_OF */}, 
	{"isa?", 9 /* TT_ISA */}, 
	{"in?", 9 /* TT_IN */}, 
	{"=~", 9 /* TT_MATCH */}, 
	{"==", 9 /* TT_EQ */}, 
	{"!=", 9 /* TT_NEQ */}, 
	{"<", 9 /* TT_LT */}, 
	{"<=", 9 /* TT_LTE */}, 
	{">", 9 /* TT_GT */}, 
	{">=", 9 /* TT_GTE */}, 
	{"from", 15 /* TT_FROM */}, 
	{"where", 15 /* TT_WHERE */}, 
	{"to", 15 /* TT_TO */}, 
	{"until", 15 /* TT_UNTIL */}, 
	{"<<<", 15 /* TT_LSFT */}, 
	{">>", 15 /* TT_RSFT */}, 
	{"+", 20 /* TT_ADD */}, 
	{"-", 20 /* TT_SUB */}, 
	{"/", 24 /* TT_DIV */}, 
	{"%", 24 /* TT_MOD */}, 
	{"*", 24 /* TT_MUL */}, 
	{"&", 27 /* TT_LAND */}, 
	{"|", 27 /* TT_LOR */}, 
	{"^", 27 /* TT_XOR */}, 
	{"~", 27 /* TT_LNOT */}, 
	{"++", 28 /* TT_NEXT */}, 
	{"--", 28 /* TT_PREV */}, 
	{"**", 28 /* TT_PATH */}, 
	{"..", 28 /* TT_ITR */}, 
	{"***", 28 /* TT_TMUL */}, 
	{"+++", 28 /* TT_TADD */}, 
	{"&&&", 28 /* TT_ADDR */}, 
	{"---", 28 /* TT_TSUB */}, 
	{NULL, 0},
};

static int knh_term_getOPRpriority(knh_term_t tt)
{
	if(TT_LET <= tt && tt <= TT_TSUB) {
		return knh_opdata[tt-TT_LET].priority;
	}
	if(TT_ASIS <= tt && tt < TT_ERR) {
	    return 99;
	}
	return 0;
}

char* knh_getopname(knh_methodn_t mn)
{
	DBG_ASSERT(mn + TT_LET <= TT_TSUB);
	return knh_opdata[mn].opname;
}
#endif/*K_USING_TERMCODE*/
